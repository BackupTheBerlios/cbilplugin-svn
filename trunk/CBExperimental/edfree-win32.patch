Index: src/sdk/projectmanager.cpp
===================================================================
--- src/sdk/projectmanager.cpp	(revision 4255)
+++ src/sdk/projectmanager.cpp	(working copy)
@@ -55,6 +55,7 @@
 #include <wx/textdlg.h>
 #include <wx/progdlg.h>
 #include "wx/wxFlatNotebook/wxFlatNotebook.h"
+#include "tearawaynotebook.h"
 
 #include "incrementalselectlistdlg.h"
 #include "filegroupsandmasks.h"
@@ -80,7 +81,6 @@
 // static
 bool ProjectManager::s_CanShutdown = true;
 
-
 int ID_ProjectManager = wxNewId();
 int idMenuSetActiveProject = wxNewId();
 int idMenuOpenFile = wxNewId();
@@ -122,6 +122,7 @@
 static const int idNB = wxNewId();
 static const int idNB_TabTop = wxNewId();
 static const int idNB_TabBottom = wxNewId();
+static const int idNB_TabDetach = wxNewId();
 
 #ifndef __WXMSW__
 /*
@@ -168,10 +169,13 @@
     EVT_TREE_ITEM_RIGHT_CLICK(ID_ProjectManager, ProjectManager::OnTreeItemRightClick)
     EVT_COMMAND_RIGHT_CLICK(ID_ProjectManager, ProjectManager::OnRightClick)
 
+    EVT_FLATNOTEBOOK_CONTEXT_MENU(idNB, ProjectManager::OnPageContextMenu)
+
     EVT_MENU_RANGE(idOpenWith[0], idOpenWith[MAX_OPEN_WITH_ITEMS - 1], ProjectManager::OnOpenWith)
     EVT_MENU(idOpenWithInternal, ProjectManager::OnOpenWith)
     EVT_MENU(idNB_TabTop, ProjectManager::OnTabPosition)
     EVT_MENU(idNB_TabBottom, ProjectManager::OnTabPosition)
+    EVT_MENU(idNB_TabDetach, ProjectManager::OnDetach)
     EVT_MENU(idMenuSetActiveProject, ProjectManager::OnSetActiveProject)
     EVT_MENU(idMenuNextProject, ProjectManager::OnSetActiveProject)
     EVT_MENU(idMenuPriorProject, ProjectManager::OnSetActiveProject)
@@ -225,15 +229,10 @@
     m_isCheckingForExternallyModifiedProjects(false),
     m_CanSendWorkspaceChanged(false)
 {
-    m_pNotebook = new wxFlatNotebook(Manager::Get()->GetAppWindow(), idNB);
+    m_pNotebook = new TearawayNotebook(Manager::Get()->GetAppWindow(), idNB);
     m_pNotebook->SetWindowStyleFlag(Manager::Get()->GetConfigManager(_T("app"))->ReadInt(_T("/environment/project_tabs_style"), wxFNB_NO_X_BUTTON));
     m_pNotebook->SetImageList(new wxFlatNotebookImageList);
 
-    wxMenu* NBmenu = new wxMenu(); // deleted automatically by wxFlatNotebook
-    NBmenu->Append(idNB_TabTop, _("Tabs at top"));
-    NBmenu->Append(idNB_TabBottom, _("Tabs at bottom"));
-    m_pNotebook->SetRightClickMenu(NBmenu);
-
     m_InitialDir=wxFileName::GetCwd();
     m_pActiveProject = 0L;
     m_pProjects = new ProjectsArray;
@@ -264,6 +263,7 @@
     // this is a core manager, so it is removed when the app is shutting down.
     // in this case, the app has already un-hooked us, so no need to do it ourselves...
 //    Manager::Get()->GetAppWindow()->RemoveEventHandler(this);
+    m_pNotebook->UndetachAllPages();
 
     delete m_pWorkspace;
     m_pWorkspace = 0;
@@ -292,6 +292,7 @@
     if(m_pTree)
         return;
     BuildTree();
+
     m_pNotebook->AddPage(m_pTree, _("Projects"));
 }
 
@@ -328,7 +329,9 @@
     #else
         m_pTree = new wxTreeCtrl(m_pNotebook, ID_ProjectManager, wxDefaultPosition, wxDefaultSize, wxTR_EDIT_LABELS | wxTR_DEFAULT_STYLE | wxNO_BORDER);
     #endif
+    m_pTree->SetAutoLayout(TRUE);
 
+
     static const wxString imgs[] = {
 
         // NOTE: Keep in sync with FileVisualState in globals.h!
@@ -2502,6 +2505,21 @@
     }
 }
 
+void ProjectManager::OnDetach(wxCommandEvent& event)
+{
+    size_t page=m_pNotebook->GetSelection();
+    if(m_pNotebook->IsDetached(page))
+    {
+        m_pNotebook->UndetachPage(page);
+    }
+    else
+    {
+        m_pNotebook->DetachPage(page,_T("")); //TODO: figure out sensible window name (full path to file)
+    }
+
+}
+
+
 void ProjectManager::WorkspaceChanged()
 {
     // We use IsBusy() to check *ALL* the conditions: If we're in the process of
@@ -2790,3 +2808,18 @@
         CloseWorkspace();
     }
 }
+
+void ProjectManager::OnPageContextMenu(wxFlatNotebookEvent& event)
+{
+    if (event.GetSelection() == -1)
+        return;
+    wxMenu* pop = new wxMenu;
+    if(m_pNotebook->IsDetached(m_pNotebook->GetSelection()))
+        pop->Append(idNB_TabDetach, _("Reattach"));
+    else
+        pop->Append(idNB_TabDetach, _("Detach"));
+    pop->Append(idNB_TabTop, _("Tabs at top"));
+    pop->Append(idNB_TabBottom, _("Tabs at bottom"));
+    m_pNotebook->PopupMenu(pop);
+    delete pop;
+}
Index: src/sdk/tearawaynotebook.cpp
===================================================================
--- src/sdk/tearawaynotebook.cpp	(revision 0)
+++ src/sdk/tearawaynotebook.cpp	(revision 0)
@@ -0,0 +1,294 @@
+#include "tearawaynotebook.h"
+#include "sdk_events.h"
+#include "manager.h"
+
+#include <wx/arrimpl.cpp>
+WX_DEFINE_OBJARRAY(wxWindowArray);
+
+
+IMPLEMENT_DYNAMIC_CLASS(TearawayNotebook, wxFlatNotebook)
+
+BEGIN_EVENT_TABLE(TearawayNotebook, wxFlatNotebook)
+//EVT_COMMAND_FLATNOTEBOOK_PAGE_CHANGING(TearawayNotebook::);
+EVT_DOCK_WINDOW_VISIBILITY(TearawayNotebook::OnDockWindowVisibility)
+END_EVENT_TABLE()
+
+
+TearawayNotebook::~TearawayNotebook()
+{
+//    cbMessageBox(wxString::Format(_T("tearaway notebook destructor")));
+    for(size_t i=0;i<m_detachedwindow.GetCount();i++)
+        if(m_detachedwindow[i])
+            UndetachPage(i);
+}
+
+bool TearawayNotebook::IsDetached(size_t page)
+{
+    if(page>m_detachedwindow.GetCount())
+        return false;
+    return m_detachedwindow[page];
+}
+
+bool TearawayNotebook::DetachPage(size_t page, wxString windowname)
+{
+    if (m_detachedwindow[page])
+        return false;
+    if(page >= m_windows.GetCount())
+        return false;
+//	// Support for disabed tabs
+//	if(!m_pages->GetEnabled(page) && m_windows.GetCount() > 1 && !m_bForceSelection)
+//		return;
+
+    int newfocal=GetPreviousSelection();
+    if(newfocal==wxNOT_FOUND)
+        newfocal=page;
+    if(newfocal==page || m_detachedwindow[newfocal])
+        for(size_t i=0;i<m_detachedwindow.GetCount();i++)
+        {
+            if(m_detachedwindow[i]==NULL && i!=page)
+            {
+                newfocal=i;
+                break;
+            }
+        }
+    if(newfocal==page)
+    {
+        int curSel = m_pages->GetSelection();
+        if(curSel >= 0 && !m_detachedwindow[curSel])
+        {
+            Freeze();
+            // Remove the window from the main sizer
+            m_mainSizer->Detach(m_windows[curSel]);
+            m_windows[curSel]->Hide();
+            Thaw();
+        }
+    }
+    else
+        SetSelection(newfocal);
+
+
+    CodeBlocksDockEvent evt(cbEVT_ADD_DOCK_WINDOW);
+    evt.name = GetPageText(page); //windowname;
+    evt.title = GetPageText(page);
+    evt.pWindow = GetPage(page);
+    evt.dockSide = CodeBlocksDockEvent::dsFloating;
+    evt.desiredSize.Set(350, 250);
+    evt.floatingSize.Set(350, 250);
+    evt.minimumSize.Set(150, 150);
+    evt.shown = true;
+    evt.hideable = true;
+    evt.stretch=false;
+    m_detachedwindow[page]=GetPage(page);
+    Manager::Get()->ProcessEvent(evt);
+    return true;
+}
+
+
+bool TearawayNotebook::UndetachPage(size_t page)
+{
+    if (m_detachedwindow[page])
+    {
+        CodeBlocksDockEvent evt(cbEVT_REMOVE_DOCK_WINDOW);
+        evt.pWindow = m_detachedwindow[page];
+        Manager::Get()->ProcessEvent(evt);
+        m_detachedwindow[page]->Reparent(this);
+        m_detachedwindow[page]=NULL;
+        if(page==static_cast<size_t>(GetSelection()))
+        {
+            Freeze();
+            if(m_windowStyle & wxFNB_BOTTOM)
+            {
+                m_mainSizer->Insert(0, m_windows[page], 1, wxEXPAND);
+            }
+            else
+            {
+                // We leave a space of 1 pixel around the window
+                m_mainSizer->Add(m_windows[page], 1, wxEXPAND);
+            }
+            m_windows[page]->Show();
+            Thaw();
+            m_mainSizer->Layout();
+        }
+        else
+        {
+            SetSelection(page);
+        }
+        return true;
+    }
+    return false;
+}
+
+void TearawayNotebook::UndetachAllPages()
+{
+    for(size_t i=0;i<m_detachedwindow.GetCount();i++)
+        if(m_detachedwindow[i])
+            UndetachPage(i);
+}
+
+
+void TearawayNotebook::SetSelection(size_t page)
+{
+    if(page >= m_windows.GetCount())
+        return;
+    // Support for disabed tabs
+    if(!m_pages->GetEnabled(page) && m_windows.GetCount() > 1 && !m_bForceSelection)
+        return;
+
+    if( m_sendPageChangeEvent )
+    {
+        // Allow the user to veto the selection
+        int oldSelection = GetSelection();
+
+        wxFlatNotebookEvent event(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CHANGING, GetId());
+        event.SetSelection( (int)page );
+        event.SetOldSelection( oldSelection );
+        event.SetEventObject( this );
+        GetEventHandler()->ProcessEvent(event);
+
+        if( !event.IsAllowed() )
+        {
+            return;
+        }
+    }
+
+    // program allows the page change
+    Freeze();
+    int curSel = m_pages->GetSelection();
+    if(curSel >= 0 && !m_detachedwindow[curSel])
+    {
+        // Remove the window from the main sizer
+        m_mainSizer->Detach(m_windows[curSel]);
+        m_windows[curSel]->Hide();
+    }
+
+    if (m_detachedwindow[page])
+    {
+        CodeBlocksDockEvent evt(cbEVT_SHOW_DOCK_WINDOW);
+        evt.pWindow = GetPage(page);
+        evt.shown=true;
+        Manager::Get()->ProcessEvent(evt);
+//        m_detachedwindow[page]->SetFocus();
+    } else
+    {
+        if(m_windowStyle & wxFNB_BOTTOM)
+        {
+            m_mainSizer->Insert(0, m_windows[page], 1, wxEXPAND);
+        }
+        else
+        {
+            // We leave a space of 1 pixel around the window
+            m_mainSizer->Add(m_windows[page], 1, wxEXPAND);
+        }
+        m_windows[page]->Show();
+    }
+    Thaw();
+    m_mainSizer->Layout();
+
+    if( page != (size_t)m_pages->m_iActivePage )
+        //there is a real page changing
+        m_pages->m_iPreviousActivePage = m_pages->m_iActivePage;
+
+    m_pages->m_iActivePage = (int)page;
+    m_pages->DoSetSelection(page);
+
+    if( m_sendPageChangeEvent )
+    {
+        // Fire event 'Page Changed'
+        wxFlatNotebookEvent event(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CHANGED, GetId());
+        event.SetSelection( (int)page );
+        event.SetEventObject( this );
+        GetEventHandler()->ProcessEvent(event);
+    }
+}
+
+
+//TODO: This message never gets passed -- need to look into wxAUI events...
+void TearawayNotebook::OnDockWindowVisibility(CodeBlocksDockEvent& event)
+{
+    for(size_t i=0;i<m_detachedwindow.GetCount();i++)
+        if(m_detachedwindow[i]==event.pWindow)
+        {
+            UndetachPage(i);
+//            SetSelection(i);
+        }
+}
+
+bool TearawayNotebook::AddPage(wxWindow* page, const wxString& caption, const bool selected, const int imgindex)
+{
+//    cbMessageBox(wxString::Format(_T("adding pages numd %i numw %i"),m_detachedwindow.GetCount(),m_windows.GetCount()));
+    return InsertPage(m_windows.GetCount(),page,caption,selected,imgindex);
+}
+
+bool TearawayNotebook::InsertPage(size_t index, wxWindow* page, const wxString& text, bool select, const int imgindex)
+{
+//    cbMessageBox(wxString::Format(_T("insert page %i numd %i numw %i"),index,m_detachedwindow.GetCount(),m_windows.GetCount()));
+    m_detachedwindow.Insert((wxWindow*)NULL,index);
+    if(wxFlatNotebook::InsertPage(index,page,text,select,imgindex))
+    {
+        return true;
+    } else
+    {
+        m_detachedwindow.RemoveAt(index);
+        return false;
+    }
+}
+
+void TearawayNotebook::DeletePage(size_t page, bool notify)
+{
+//    cbMessageBox(wxString::Format(_T("deleting page %i"),page));
+    if(m_detachedwindow[page])
+        UndetachPage(page);
+    m_detachedwindow.RemoveAt(page);
+    wxFlatNotebook::DeletePage(page,notify);
+}
+
+bool TearawayNotebook::RemovePage(size_t page, bool notify)
+{
+//    cbMessageBox(wxString::Format(_T("removing page %i"),page));
+    if(m_detachedwindow[page])
+        UndetachPage(page);
+    m_detachedwindow.RemoveAt(page);
+    bool result=wxFlatNotebook::RemovePage(page,notify);
+    return result;
+}
+
+bool TearawayNotebook::DeleteAllPages()
+{
+//    cbMessageBox(_T("deleting all"));
+    for(size_t i=0;i<m_detachedwindow.GetCount();i++)
+        if(m_detachedwindow[i])
+            UndetachPage(i);
+    return wxFlatNotebook::DeleteAllPages();
+}
+
+wxString TearawayNotebook::GetDetached()
+{
+    wxString s;
+    for(size_t i=0;i<m_detachedwindow.GetCount();i++)
+    {
+        s+=GetPageText(i)+_T(";");
+        s+=(m_detachedwindow[i]!=0)?_T("1;"):_T("0;");
+    }
+    return s;
+}
+
+
+void TearawayNotebook::SetDetached(wxString s)
+{
+    while(!s.IsEmpty())
+    {
+        wxString pagename=s.BeforeFirst(';');
+        s=s.AfterFirst(';');
+        wxString detached=s.BeforeFirst(';');
+        s=s.AfterFirst(';');
+        for(size_t i=0;i<m_detachedwindow.GetCount();i++)
+            if(GetPageText(i)==pagename)
+                if(detached==_T("0"))
+                    UndetachPage(i);
+                else
+                {
+                    SetSelection(i);
+                    DetachPage(i, wxEmptyString);
+                }
+    }
+}
Index: src/sdk/messagemanager.cpp
===================================================================
--- src/sdk/messagemanager.cpp	(revision 4255)
+++ src/sdk/messagemanager.cpp	(working copy)
@@ -51,6 +51,7 @@
 #include <wx/filedlg.h>
 
 #include "wx/wxFlatNotebook/wxFlatNotebook.h"
+#include "tearawaynotebook.h"
 
 // Custom window to shutdown the app when closed.
 // used for batch builds only.
@@ -117,6 +118,7 @@
 static const int idNB = wxNewId();
 static const int idNB_TabTop = wxNewId();
 static const int idNB_TabBottom = wxNewId();
+static const int idNBTabDetach = wxNewId();
 
 // 64 logs should be more than enough
 static const int MAX_LOGS = 64;
@@ -136,6 +138,7 @@
     EVT_MENU_RANGE(idNB_ShowHide[0], idNB_ShowHide[MAX_LOGS - 1], MessageManager::OnShowHideLog)
     EVT_MENU(idNB_TabTop, MessageManager::OnTabPosition)
     EVT_MENU(idNB_TabBottom, MessageManager::OnTabPosition)
+    EVT_MENU(idNBTabDetach, MessageManager::OnDetach)
     EVT_APP_STARTUP_DONE(MessageManager::OnAppDoneStartup)
     EVT_APP_START_SHUTDOWN(MessageManager::OnAppStartShutdown)
     EVT_FLATNOTEBOOK_PAGE_CHANGED(idNB, MessageManager::OnPageChanged)
@@ -154,7 +157,7 @@
     m_HasErrors(false)
 {
 
-    m_pNotebook = new wxFlatNotebook(Manager::Get()->GetAppWindow(), idNB);
+    m_pNotebook = new TearawayNotebook(Manager::Get()->GetAppWindow(), idNB);
     m_pNotebook->SetWindowStyleFlag(Manager::Get()->GetConfigManager(_T("app"))->ReadInt(_T("/environment/message_tabs_style"), wxFNB_BOTTOM | wxFNB_NO_X_BUTTON));
     m_pNotebook->SetImageList(new wxFlatNotebookImageList);
 
@@ -692,6 +695,10 @@
 void MessageManager::OnPageContextMenu(wxFlatNotebookEvent& event)
 {
     wxMenu* NBmenu = new wxMenu();
+    if(m_pNotebook->IsDetached(m_pNotebook->GetSelection()))
+        NBmenu->Append(idNBTabDetach, _("Reattach"));
+    else
+        NBmenu->Append(idNBTabDetach, _("Detach"));
     NBmenu->Append(idNB_TabTop, _("Tabs at top"));
     NBmenu->Append(idNB_TabBottom, _("Tabs at bottom"));
     NBmenu->AppendSeparator();
@@ -711,3 +718,17 @@
     m_pNotebook->PopupMenu(NBmenu);
     delete NBmenu;
 }
+
+void MessageManager::OnDetach(wxCommandEvent& event)
+{
+    size_t page=m_pNotebook->GetSelection();
+    if(m_pNotebook->IsDetached(page))
+    {
+        m_pNotebook->UndetachPage(page);
+    }
+    else
+    {
+        m_pNotebook->DetachPage(page,_T("")); //TODO: figure out sensible window name (full path to file)
+    }
+
+}
Index: src/sdk/editorbase.cpp
===================================================================
--- src/sdk/editorbase.cpp	(revision 4255)
+++ src/sdk/editorbase.cpp	(working copy)
@@ -25,6 +25,7 @@
     #include <wx/wfstream.h>
 #endif
 
+#include "tearawaynotebook.h"
 #include "wx/wxFlatNotebook/wxFlatNotebook.h"
 
 // needed for initialization of variables
Index: src/sdk/wxFlatNotebook/src/wxFlatNotebook/wxFlatNotebook.cpp
===================================================================
--- src/sdk/wxFlatNotebook/src/wxFlatNotebook/wxFlatNotebook.cpp	(revision 4255)
+++ src/sdk/wxFlatNotebook/src/wxFlatNotebook/wxFlatNotebook.cpp	(working copy)
@@ -1,50 +1,50 @@
-///////////////////////////////////////////////////////////////////////////////
-// Name:		wxFlatNotebook.cpp
-// Purpose:     generic implementation of flat style notebook class.
-// Author:      Eran Ifrah <eranif@bezeqint.net>
-// Modified by: Priyank Bolia <soft@priyank.in>
-// Created:     30/12/2005
-// Modified:    01/01/2006
-// Copyright:   Eran Ifrah (c)
-// Licence:     wxWindows license <http://www.wxwidgets.org/licence3.txt>
-///////////////////////////////////////////////////////////////////////////////
-
-#include <wx/wxFlatNotebook/wxFlatNotebook.h>
-#include <wx/wxFlatNotebook/renderer.h>
-#include <wx/wxFlatNotebook/popup_dlg.h>
-#include <algorithm>
-#include <wx/tooltip.h>
-#include <wx/tipwin.h>
-#include <wx/arrimpl.cpp>
-
-#ifdef DEVELOPMENT
-# define FNB_LOG_MSG( msg ) { wxString logmsg; logmsg << msg; wxLogMessage( logmsg ); }
-#else
-# define FNB_LOG_MSG( msg ) { wxString logmsg; logmsg << msg; }
-#endif
-
-#ifdef DEVELOPMENT
-#include <map>
-wxString WhereToString( int where )
-{
-	static std::map<int, wxString> whereMap;
-	static bool first = true;
-
-	if( first )
-	{
-		whereMap[wxFNB_TAB] = wxT("wxFNB_TAB");
-		whereMap[wxFNB_X] = wxT("wxFNB_X");
-		whereMap[wxFNB_TAB_X] = wxT("wxFNB_TAB_X");
-		whereMap[wxFNB_LEFT_ARROW] = wxT("wxFNB_LEFT_ARROW");
-		whereMap[wxFNB_RIGHT_ARROW] = wxT("wxFNB_RIGHT_ARROW");
-		whereMap[wxFNB_DROP_DOWN_ARROW] = wxT("wxFNB_DROP_DOWN_ARROW");
-		whereMap[wxFNB_NOWHERE] = wxT("wxFNB_NOWHERE");
-		first = false;
-	}
-	return whereMap[where];
-}
-#endif
+///////////////////////////////////////////////////////////////////////////////
+// Name:		wxFlatNotebook.cpp
+// Purpose:     generic implementation of flat style notebook class.
+// Author:      Eran Ifrah <eranif@bezeqint.net>
+// Modified by: Priyank Bolia <soft@priyank.in>
+// Created:     30/12/2005
+// Modified:    01/01/2006
+// Copyright:   Eran Ifrah (c)
+// Licence:     wxWindows license <http://www.wxwidgets.org/licence3.txt>
+///////////////////////////////////////////////////////////////////////////////
 
+#include <wx/wxFlatNotebook/wxFlatNotebook.h>
+#include <wx/wxFlatNotebook/renderer.h>
+#include <wx/wxFlatNotebook/popup_dlg.h>
+#include <algorithm>
+#include <wx/tooltip.h>
+#include <wx/tipwin.h>
+#include <wx/arrimpl.cpp>
+
+#ifdef DEVELOPMENT
+# define FNB_LOG_MSG( msg ) { wxString logmsg; logmsg << msg; wxLogMessage( logmsg ); }
+#else
+# define FNB_LOG_MSG( msg ) { wxString logmsg; logmsg << msg; }
+#endif
+
+#ifdef DEVELOPMENT
+#include <map>
+wxString WhereToString( int where )
+{
+	static std::map<int, wxString> whereMap;
+	static bool first = true;
+
+	if( first )
+	{
+		whereMap[wxFNB_TAB] = wxT("wxFNB_TAB");
+		whereMap[wxFNB_X] = wxT("wxFNB_X");
+		whereMap[wxFNB_TAB_X] = wxT("wxFNB_TAB_X");
+		whereMap[wxFNB_LEFT_ARROW] = wxT("wxFNB_LEFT_ARROW");
+		whereMap[wxFNB_RIGHT_ARROW] = wxT("wxFNB_RIGHT_ARROW");
+		whereMap[wxFNB_DROP_DOWN_ARROW] = wxT("wxFNB_DROP_DOWN_ARROW");
+		whereMap[wxFNB_NOWHERE] = wxT("wxFNB_NOWHERE");
+		first = false;
+	}
+	return whereMap[where];
+}
+#endif
+
 inline bool RectContains(wxRect& rect,const wxPoint pt)
 {
     #if wxVERSION_NUMBER >= 2800
@@ -53,1692 +53,1693 @@
         return rect.Inside(pt);
     #endif
 }
-
-//-------------------------------------------------------------------
-// Provide user with a nice feedback when tab is being dragged
-//-------------------------------------------------------------------
-bool wxFNBDropSource::GiveFeedback(wxDragResult effect)
-{
-	wxUnusedVar(effect);
-	static_cast<wxPageContainer*>( m_win )->DrawDragHint();
-	return false;
-}
-
-IMPLEMENT_DYNAMIC_CLASS(wxFlatNotebookEvent, wxNotifyEvent)
-DEFINE_EVENT_TYPE(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CHANGED)
-DEFINE_EVENT_TYPE(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CHANGING)
-DEFINE_EVENT_TYPE(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSING)
-DEFINE_EVENT_TYPE(wxEVT_COMMAND_FLATNOTEBOOK_CONTEXT_MENU)
-DEFINE_EVENT_TYPE(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSED)
-
-IMPLEMENT_DYNAMIC_CLASS(wxFlatNotebook, wxPanel)
-
-WX_DEFINE_OBJARRAY(wxFlatNotebookImageList);
-WX_DEFINE_OBJARRAY(wxPageInfoArray)
-WX_DEFINE_OBJARRAY(wxWindowPtrArray)
-
-BEGIN_EVENT_TABLE(wxFlatNotebook, wxPanel)
-EVT_NAVIGATION_KEY(wxFlatNotebook::OnNavigationKey)
-END_EVENT_TABLE()
-
-wxFlatNotebook::wxFlatNotebook(wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style, const wxString& name)
-: m_popupWin(NULL)
-, m_sendPageChangeEvent(true)
-{
-	m_bForceSelection = false;
-	m_nPadding = 6;
-	m_nFrom = 0;
-	style |= wxTAB_TRAVERSAL;
-	m_pages = NULL;
-	wxPanel::Create(parent, id, pos, size, style, name);
-
-	m_pages = new wxPageContainer(this, wxID_ANY, wxDefaultPosition, wxDefaultSize, style);
-	Init();
-}
-
-wxFlatNotebook::~wxFlatNotebook(void)
-{
-}
-
-void wxFlatNotebook::Init()
-{
-	m_pages->m_colorBorder = wxColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNSHADOW));
-
-	m_mainSizer = new wxBoxSizer(wxVERTICAL);
-	SetSizer(m_mainSizer);
-
-	SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_APPWORKSPACE));
-
-	// Set default page height
-	wxMemoryDC memDc;
-
-	wxBitmap bmp(10, 10);
-	memDc.SelectObject(bmp);
-
-	int width, height;
-
-
-#ifdef __WXGTK__
-	// For GTK it seems that we must do this steps in order
-	// for the tabs will get the proper height on initialization
-	// on MSW, preforming these steps yields wierd results
-	wxFont normalFont = wxSystemSettings::GetFont(wxSYS_DEFAULT_GUI_FONT);
-	wxFont boldFont = normalFont;
-	boldFont.SetWeight(wxFONTWEIGHT_BOLD);
-	memDc.SetFont( boldFont );
-#endif
-
-	wxString stam = wxT("Tp");	// Temp data to get the text height;
-	memDc.GetTextExtent(stam, &width, &height);
-
-	int tabHeight = height + wxFNB_HEIGHT_SPACER; // We use 8 pixels as padding
-#ifdef __WXGTK__
-	// On GTK the tabs are should be larger
-	tabHeight += 6;
-#endif
-	m_pages->SetSizeHints(wxSize(-1, tabHeight));
-
-	// Add the tab container to the sizer
-	m_mainSizer->Insert(0, m_pages, 0, wxEXPAND);
-	m_mainSizer->Layout();
-
-	m_pages->m_nFrom = m_nFrom;
-	m_pDropTarget = new wxFNBDropTarget<wxFlatNotebook>(this, &wxFlatNotebook::OnDropTarget);
-	SetDropTarget(m_pDropTarget);
-}
-
-void wxFlatNotebook::SetActiveTabTextColour(const wxColour& textColour)
-{
-	m_pages->m_activeTextColor = textColour;
-}
-
-wxDragResult wxFlatNotebook::OnDropTarget(wxCoord x, wxCoord y, int nTabPage, wxWindow * wnd_oldContainer)
-{
-	return m_pages->OnDropTarget(x, y, nTabPage, wnd_oldContainer);
-}
-
-int wxFlatNotebook::GetPreviousSelection() const
-{
-	return m_pages->m_iPreviousActivePage;
-}
-
-bool wxFlatNotebook::AddPage(wxWindow* window, const wxString& caption, const bool selected, const int imgindex)
-{
-	return InsertPage(m_windows.GetCount(), window, caption, selected, imgindex);
-}
-
-void wxFlatNotebook::SetImageList(wxFlatNotebookImageList * imglist)
-{
-	m_pages->SetImageList(imglist);
-}
-
-wxFlatNotebookImageList * wxFlatNotebook::GetImageList()
-{
-	return m_pages->GetImageList();
-}
-
-bool wxFlatNotebook::InsertPage(size_t index, wxWindow* page, const wxString& text, bool select, const int imgindex)
-{
-	// sanity check
-	if (!page)
-		return false;
-
-	// reparent the window to us
-	page->Reparent(this);
-
-	if( !m_pages->IsShown() )
-		m_pages->Show();
-
-	index = FNB_MIN((unsigned int)index, (unsigned int)m_windows.GetCount());
-	// Insert tab
-	bool bSelected = select || m_windows.empty();
-	int curSel = m_pages->GetSelection();
-
-	if(index <= m_windows.GetCount())
-	{
-		m_windows.Insert(page, index);
-		wxLogTrace(wxTraceMask(), wxT("New page inserted. Index = %i"), index);
-	}
-	else
-	{
-		m_windows.Add(page);
-		wxLogTrace(wxTraceMask(), wxT("New page appended. Index = %i"), index);
-	}
-
-	if( !m_pages->InsertPage(index, page, text, bSelected, imgindex) )
-		return false;
-
-	if((int)index <= curSel) curSel++;
-
-	Freeze();
-
-	// Check if a new selection was made
-	if(bSelected)
-	{
-		if(curSel >= 0)
-		{
-			// Remove the window from the main sizer
-			m_mainSizer->Detach(m_windows[curSel]);
-			m_windows[curSel]->Hide();
-		}
-		m_pages->SetSelection(index);
-	}
-	else
-	{
-		// Hide the page
-		page->Hide();
-	}
-	m_mainSizer->Layout();
-	Thaw();
-	Refresh();
-
-	return true;
-}
-
-void wxFlatNotebook::SetSelection(size_t page)
-{
-	if(page >= m_windows.GetCount())
-		return;
-
-	// Support for disabed tabs
-	if(!m_pages->GetEnabled(page) && m_windows.GetCount() > 1 && !m_bForceSelection)
-		return;
-
-	if( m_sendPageChangeEvent )
-	{
-		// Allow the user to veto the selection
-		int oldSelection = GetSelection();
-
-		wxFlatNotebookEvent event(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CHANGING, GetId());
-		event.SetSelection( (int)page );
-		event.SetOldSelection( oldSelection );
+
+//-------------------------------------------------------------------
+// Provide user with a nice feedback when tab is being dragged
+//-------------------------------------------------------------------
+bool wxFNBDropSource::GiveFeedback(wxDragResult effect)
+{
+	wxUnusedVar(effect);
+	static_cast<wxPageContainer*>( m_win )->DrawDragHint();
+	return false;
+}
+
+IMPLEMENT_DYNAMIC_CLASS(wxFlatNotebookEvent, wxNotifyEvent)
+DEFINE_EVENT_TYPE(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CHANGED)
+DEFINE_EVENT_TYPE(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CHANGING)
+DEFINE_EVENT_TYPE(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSING)
+DEFINE_EVENT_TYPE(wxEVT_COMMAND_FLATNOTEBOOK_CONTEXT_MENU)
+DEFINE_EVENT_TYPE(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSED)
+
+IMPLEMENT_DYNAMIC_CLASS(wxFlatNotebook, wxPanel)
+
+WX_DEFINE_OBJARRAY(wxFlatNotebookImageList);
+WX_DEFINE_OBJARRAY(wxPageInfoArray)
+WX_DEFINE_OBJARRAY(wxWindowPtrArray)
+
+BEGIN_EVENT_TABLE(wxFlatNotebook, wxPanel)
+EVT_NAVIGATION_KEY(wxFlatNotebook::OnNavigationKey)
+
+END_EVENT_TABLE()
+
+wxFlatNotebook::wxFlatNotebook(wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style, const wxString& name)
+: m_popupWin(NULL)
+, m_sendPageChangeEvent(true)
+{
+	m_bForceSelection = false;
+	m_nPadding = 6;
+	m_nFrom = 0;
+	style |= wxTAB_TRAVERSAL;
+	m_pages = NULL;
+	wxPanel::Create(parent, id, pos, size, style, name);
+
+	m_pages = new wxPageContainer(this, wxID_ANY, wxDefaultPosition, wxDefaultSize, style);
+	Init();
+}
+
+wxFlatNotebook::~wxFlatNotebook(void)
+{
+}
+
+void wxFlatNotebook::Init()
+{
+	m_pages->m_colorBorder = wxColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNSHADOW));
+
+	m_mainSizer = new wxBoxSizer(wxVERTICAL);
+	SetSizer(m_mainSizer);
+
+	SetBackgroundColour(wxSystemSettings::GetColour(wxSYS_COLOUR_APPWORKSPACE));
+
+	// Set default page height
+	wxMemoryDC memDc;
+
+	wxBitmap bmp(10, 10);
+	memDc.SelectObject(bmp);
+
+	int width, height;
+
+
+#ifdef __WXGTK__
+	// For GTK it seems that we must do this steps in order
+	// for the tabs will get the proper height on initialization
+	// on MSW, preforming these steps yields wierd results
+	wxFont normalFont = wxSystemSettings::GetFont(wxSYS_DEFAULT_GUI_FONT);
+	wxFont boldFont = normalFont;
+	boldFont.SetWeight(wxFONTWEIGHT_BOLD);
+	memDc.SetFont( boldFont );
+#endif
+
+	wxString stam = wxT("Tp");	// Temp data to get the text height;
+	memDc.GetTextExtent(stam, &width, &height);
+
+	int tabHeight = height + wxFNB_HEIGHT_SPACER; // We use 8 pixels as padding
+#ifdef __WXGTK__
+	// On GTK the tabs are should be larger
+	tabHeight += 6;
+#endif
+	m_pages->SetSizeHints(wxSize(-1, tabHeight));
+
+	// Add the tab container to the sizer
+	m_mainSizer->Insert(0, m_pages, 0, wxEXPAND);
+	m_mainSizer->Layout();
+
+	m_pages->m_nFrom = m_nFrom;
+	m_pDropTarget = new wxFNBDropTarget<wxFlatNotebook>(this, &wxFlatNotebook::OnDropTarget);
+	SetDropTarget(m_pDropTarget);
+}
+
+void wxFlatNotebook::SetActiveTabTextColour(const wxColour& textColour)
+{
+	m_pages->m_activeTextColor = textColour;
+}
+
+wxDragResult wxFlatNotebook::OnDropTarget(wxCoord x, wxCoord y, int nTabPage, wxWindow * wnd_oldContainer)
+{
+	return m_pages->OnDropTarget(x, y, nTabPage, wnd_oldContainer);
+}
+
+int wxFlatNotebook::GetPreviousSelection() const
+{
+	return m_pages->m_iPreviousActivePage;
+}
+
+bool wxFlatNotebook::AddPage(wxWindow* window, const wxString& caption, const bool selected, const int imgindex)
+{
+	return InsertPage(m_windows.GetCount(), window, caption, selected, imgindex);
+}
+
+void wxFlatNotebook::SetImageList(wxFlatNotebookImageList * imglist)
+{
+	m_pages->SetImageList(imglist);
+}
+
+wxFlatNotebookImageList * wxFlatNotebook::GetImageList()
+{
+	return m_pages->GetImageList();
+}
+
+bool wxFlatNotebook::InsertPage(size_t index, wxWindow* page, const wxString& text, bool select, const int imgindex)
+{
+	// sanity check
+	if (!page)
+		return false;
+
+	// reparent the window to us
+	page->Reparent(this);
+
+	if( !m_pages->IsShown() )
+		m_pages->Show();
+
+	index = FNB_MIN((unsigned int)index, (unsigned int)m_windows.GetCount());
+	// Insert tab
+	bool bSelected = select || m_windows.empty();
+	int curSel = m_pages->GetSelection();
+
+	if(index <= m_windows.GetCount())
+	{
+		m_windows.Insert(page, index);
+		wxLogTrace(wxTraceMask(), wxT("New page inserted. Index = %i"), index);
+	}
+	else
+	{
+		m_windows.Add(page);
+		wxLogTrace(wxTraceMask(), wxT("New page appended. Index = %i"), index);
+	}
+
+	if( !m_pages->InsertPage(index, page, text, bSelected, imgindex) )
+		return false;
+
+	if((int)index <= curSel) curSel++;
+
+	Freeze();
+
+	// Check if a new selection was made
+	if(bSelected)
+	{
+		if(curSel >= 0)
+		{
+			// Remove the window from the main sizer
+			m_mainSizer->Detach(m_windows[curSel]);
+			m_windows[curSel]->Hide();
+		}
+		m_pages->SetSelection(index);
+	}
+	else
+	{
+		// Hide the page
+		page->Hide();
+	}
+	m_mainSizer->Layout();
+	Thaw();
+	Refresh();
+
+	return true;
+}
+
+void wxFlatNotebook::SetSelection(size_t page)
+{
+	if(page >= m_windows.GetCount())
+		return;
+
+	// Support for disabed tabs
+	if(!m_pages->GetEnabled(page) && m_windows.GetCount() > 1 && !m_bForceSelection)
+		return;
+
+	if( m_sendPageChangeEvent )
+	{
+		// Allow the user to veto the selection
+		int oldSelection = GetSelection();
+
+		wxFlatNotebookEvent event(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CHANGING, GetId());
+		event.SetSelection( (int)page );
+		event.SetOldSelection( oldSelection );
 		event.SetEventObject( this );
-		GetEventHandler()->ProcessEvent(event);
-
-		if( !event.IsAllowed() )
-		{
-			return;
-		}
-	}
-
-	int curSel = m_pages->GetSelection();
-
-	// program allows the page change
-	Freeze();
-	if(curSel >= 0)
-	{
-		// Remove the window from the main sizer
-		m_mainSizer->Detach(m_windows[curSel]);
-		m_windows[curSel]->Hide();
-	}
-
-	if(m_windowStyle & wxFNB_BOTTOM)
-	{
-		m_mainSizer->Insert(0, m_windows[page], 1, wxEXPAND);
-	}
-	else
-	{
-		// We leave a space of 1 pixel around the window
-		m_mainSizer->Add(m_windows[page], 1, wxEXPAND);
-	}
-
-	m_windows[page]->Show();
-	Thaw();
-	m_mainSizer->Layout();
-
-	if( page != (size_t)m_pages->m_iActivePage )
-		//there is a real poge changing
-		m_pages->m_iPreviousActivePage = m_pages->m_iActivePage;
-
-	m_pages->m_iActivePage = (int)page;
-	m_pages->DoSetSelection(page);
-
-	if( m_sendPageChangeEvent )
-	{
-		// Fire event 'Page Changed'
-		wxFlatNotebookEvent event(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CHANGED, GetId());
-		event.SetSelection( (int)page );
-		event.SetEventObject( this );
-		GetEventHandler()->ProcessEvent(event);
-	}
-}
-
-void wxFlatNotebook::DeletePage(size_t page, bool notify)
-{
-	if(page >= m_windows.GetCount())
-		return;
-
-	// Fire a closing event
-	if( notify )
-	{
-		wxFlatNotebookEvent event(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSING, GetId());
-		event.SetSelection((int)page);
-		event.SetEventObject(this);
-		GetEventHandler()->ProcessEvent(event);
-
-
-		// The event handler allows it?
-		if (!event.IsAllowed())
-			return;
-	}
-
-	Freeze();
-
-	// Delete the requested page
-	wxWindow *pageRemoved = m_windows[page];
-
-	// If the page is the current window, remove it from the sizer
-	// as well
-	if((int)page == m_pages->GetSelection())
-	{
-		m_mainSizer->Detach(pageRemoved);
-	}
-
-	// Remove it from the array as well
-	m_windows.RemoveAt(page);
-
-	// Now we can destroy it; in wxWidgets use Destroy instead of delete
-	pageRemoved->Destroy();
-
-	Thaw();
-
-	m_pages->DoDeletePage(page);
-	Refresh();
-
-	// Fire a closed event
-	if( notify )
-	{
-		wxFlatNotebookEvent closedEvent(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSED, GetId());
-		closedEvent.SetSelection((int)page);
-		closedEvent.SetEventObject(this);
-		GetEventHandler()->ProcessEvent(closedEvent);
-	}
-}
-
-bool wxFlatNotebook::DeleteAllPages()
-{
-	if(m_windows.empty())
-		return false;
-
-	Freeze();
-	int i = 0;
-	for(; i<(int)m_windows.GetCount(); i++)
-	{
-		delete m_windows[i];
-	}
-
-	m_windows.Clear();
-	Thaw();
-
-	// Clear the container of the tabs as well
-	m_pages->DeleteAllPages();
-	return true;
-}
-
-wxWindow* wxFlatNotebook::GetCurrentPage() const
-{
-	int sel = m_pages->GetSelection();
-	if(sel < 0)
-		return NULL;
-
-	return m_windows[sel];
-}
-
-wxWindow* wxFlatNotebook::GetPage(size_t page) const
-{
-	if(page >= m_windows.GetCount())
-		return NULL;
-
-	return m_windows[page];
-}
-
-int wxFlatNotebook::GetPageIndex(wxWindow* win) const
-{
-	for (size_t i = 0; i < m_windows.GetCount(); ++i)
-	{
-		if (m_windows[i] == win)
-			return (int)i;
-	}
-	return -1;
-}
-
-int wxFlatNotebook::GetSelection() const
-{
-	return m_pages->GetSelection();
-}
-
-void wxFlatNotebook::AdvanceSelection(bool bForward)
-{
-	m_pages->AdvanceSelection(bForward);
-}
-
-int wxFlatNotebook::GetPageCount() const
-{
-	return (int)m_pages->GetPageCount();
-}
-
-void wxFlatNotebook::OnNavigationKey(wxNavigationKeyEvent& event)
-{
-	if ( event.IsWindowChange() )
-	{
-		if( HasFlag(wxFNB_SMART_TABS) )
-		{
-			if( !m_popupWin )
-			{
-				m_popupWin = new wxTabNavigatorWindow( this );
-				m_popupWin->ShowModal();
-				m_popupWin->Destroy();
-				m_popupWin = NULL;
-			}
-			else
-			{
-				// a dialog is already opened
-				m_popupWin->OnNavigationKey( event );
-				return;
-			}
-		}
-		else
-		{
-			// change pages
-			AdvanceSelection(event.GetDirection());
-		}
-	}
-	else
-	{
-		// pass to the parent
-		if ( GetParent() )
-		{
-			event.SetCurrentFocus(this);
-			GetParent()->ProcessEvent(event);
-		}
-	}
-}
-
-bool wxFlatNotebook::GetPageShapeAngle(int page_index, unsigned int * result)
-{
-	if(page_index < 0 || page_index >= (int)m_pages->m_pagesInfoVec.GetCount()) return false;
-	*result = m_pages->m_pagesInfoVec[page_index].GetTabAngle();
-	return true;
-}
-
-void wxFlatNotebook::SetPageShapeAngle(int page_index, unsigned int angle)
-{
-	if(page_index < 0 || page_index >= (int)m_pages->m_pagesInfoVec.GetCount()) return;
-	if(angle > 15) return;
-
-	m_pages->m_pagesInfoVec[page_index].SetTabAngle(angle);
-}
-
-void wxFlatNotebook::SetAllPagesShapeAngle(unsigned int angle)
-{
-	if(angle > 15) return;
-	for(unsigned int i = 0; i < m_pages->m_pagesInfoVec.GetCount(); i++)
-	{
-		m_pages->m_pagesInfoVec[i].SetTabAngle(angle);
-	}
-	Refresh();
-}
-
-wxSize wxFlatNotebook::GetPageBestSize()
-{
-	return m_pages->GetClientSize();
-}
-
-bool wxFlatNotebook::SetPageText(size_t page, const wxString& text)
-{
-	bool bVal = m_pages->SetPageText(page, text);
-	m_pages->Refresh();
-	return bVal;
-}
-
-void wxFlatNotebook::SetPadding(const wxSize& padding)
-{
-	m_nPadding = padding.GetWidth();
-}
-
-void wxFlatNotebook::SetWindowStyleFlag(long style)
-{
-	wxPanel::SetWindowStyleFlag(style);
-
-	if(m_pages)
-	{
-		// For changing the tab position (i.e. placing them top/bottom)
-		// refreshing the tab container is not enough
-		m_sendPageChangeEvent = false;
-		SetSelection(m_pages->m_iActivePage);
-		m_sendPageChangeEvent = true;
-	}
-}
-
-bool wxFlatNotebook::RemovePage(size_t page, bool notify)
-{
-	if(page >= m_windows.GetCount())
-		return false;
-
-	// Fire a closing event
-	if( notify )
-	{
-		wxFlatNotebookEvent event(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSING, GetId());
-		event.SetSelection((int)page);
-		event.SetEventObject(this);
-		GetEventHandler()->ProcessEvent(event);
-
-		// The event handler allows it?
-		if (!event.IsAllowed())
-			return false;
-	}
-
-	Freeze();
-
-	// Remove the requested page
-	wxWindow *pageRemoved = m_windows[page];
-
-	// If the page is the current window, remove it from the sizer
-	// as well
-	if((int)page == m_pages->GetSelection())
-	{
-		m_mainSizer->Detach(pageRemoved);
-	}
-
-	// Remove it from the array as well
-	m_windows.RemoveAt(page);
-	Thaw();
-
-	m_pages->DoDeletePage(page);
-
-	// Fire a closed event
-	if( notify )
-	{
-		wxFlatNotebookEvent closedEvent(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSED, GetId());
-		closedEvent.SetSelection((int)page);
-		closedEvent.SetEventObject(this);
-		GetEventHandler()->ProcessEvent(closedEvent);
-	}
-	return true;
-}
-
-void wxFlatNotebook::SetRightClickMenu(wxMenu* menu)
-{
-	m_pages->m_pRightClickMenu = menu;
-}
-
-wxString wxFlatNotebook::GetPageText(size_t page)
-{
-	return m_pages->GetPageText(page);
-}
-
-void wxFlatNotebook::SetGradientColors(const wxColour& from, const wxColour& to, const wxColour& border)
-{
-	m_pages->m_colorFrom = from;
-	m_pages->m_colorTo   = to;
-	m_pages->m_colorBorder = border;
-}
-
-void wxFlatNotebook::SetGradientColorFrom(const wxColour& from)
-{
-	m_pages->m_colorFrom = from;
-}
-
-void wxFlatNotebook::SetGradientColorTo(const wxColour& to)
-{
-	m_pages->m_colorTo   = to;
-}
-
-void wxFlatNotebook::SetGradientColorBorder(const wxColour& border)
-{
-	m_pages->m_colorBorder = border;
-}
-
-/// Gets first gradient colour
-const wxColour& wxFlatNotebook::GetGradientColorFrom()
-{
-	return m_pages->m_colorFrom;
-}
-
-/// Gets second gradient colour
-const wxColour& wxFlatNotebook::GetGradientColorTo()
-{
-	return m_pages->m_colorTo;
-}
-
-/// Gets the tab border colour
-const wxColour& wxFlatNotebook::SetGradientColorBorder()
-{
-	return m_pages->m_colorBorder;
-}
-
-/// Get the active tab text
-const wxColour& wxFlatNotebook::GetActiveTabTextColour()
-{
-	return m_pages->m_activeTextColor;
-}
-
-void wxFlatNotebook::SetPageImageIndex(size_t page, int imgindex)
-{
-	m_pages->SetPageImageIndex(page, imgindex);
-}
-
-int wxFlatNotebook::GetPageImageIndex(size_t page)
-{
-	return m_pages->GetPageImageIndex(page);
-}
-
-bool wxFlatNotebook::GetEnabled(size_t page)
-{
-	return m_pages->GetEnabled(page);
-}
-
-void wxFlatNotebook::Enable(size_t page, bool enabled)
-{
-	if(page >= m_windows.GetCount())
-		return;
-
-	m_windows[page]->Enable(enabled);
-	m_pages->Enable(page, enabled);
-}
-
-const wxColour& wxFlatNotebook::GetNonActiveTabTextColour()
-{
-	return m_pages->m_nonActiveTextColor;
-}
-
-void wxFlatNotebook::SetNonActiveTabTextColour(const wxColour& color)
-{
-	m_pages->m_nonActiveTextColor = color;
-}
-
-void wxFlatNotebook::SetTabAreaColour(const wxColour& color)
-{
-	m_pages->m_tabAreaColor = color;
-}
-
-const wxColour& wxFlatNotebook::GetTabAreaColour()
-{
-	return m_pages->m_tabAreaColor;
-}
-
-void wxFlatNotebook::SetActiveTabColour(const wxColour& color)
-{
-	m_pages->m_activeTabColor = color;
-}
-
-const wxColour& wxFlatNotebook::GetActiveTabColour()
-{
-	return m_pages->m_activeTabColor;
-}
-
-///////////////////////////////////////////////////////////////////////////////////////////
-//
-//	wxPageContainer
-//
-///////////////////////////////////////////////////////////////////////////////////////////
-
-BEGIN_EVENT_TABLE(wxPageContainer, wxPanel)
-EVT_PAINT(wxPageContainer::OnPaint)
-EVT_SIZE(wxPageContainer::OnSize)
-EVT_LEFT_DOWN(wxPageContainer::OnLeftDown)
-EVT_LEFT_UP(wxPageContainer::OnLeftUp)
-EVT_RIGHT_DOWN(wxPageContainer::OnRightDown)
-EVT_MIDDLE_DOWN(wxPageContainer::OnMiddleDown)
-EVT_MOTION(wxPageContainer::OnMouseMove)
-EVT_ERASE_BACKGROUND(wxPageContainer::OnEraseBackground)
-EVT_LEAVE_WINDOW(wxPageContainer::OnMouseLeave)
-EVT_ENTER_WINDOW(wxPageContainer::OnMouseEnterWindow)
-EVT_LEFT_DCLICK(wxPageContainer::OnLeftDClick)
-END_EVENT_TABLE()
-
-wxPageContainer::wxPageContainer(wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style)
-: m_ImageList(NULL)
-, m_iActivePage(-1)
-, m_pDropTarget(NULL)
-, m_nLeftClickZone(wxFNB_NOWHERE)
-, m_iPreviousActivePage(-1)
-{
-	m_pRightClickMenu = NULL;
-	m_nXButtonStatus = wxFNB_BTN_NONE;
-	m_nArrowDownButtonStatus = wxFNB_BTN_NONE;
-	m_pParent = parent;
-	m_nRightButtonStatus = wxFNB_BTN_NONE;
-	m_nLeftButtonStatus = wxFNB_BTN_NONE;
-	m_nTabXButtonStatus = wxFNB_BTN_NONE;
-
-	m_colorTo = wxColour(wxSystemSettings::GetColour(wxSYS_COLOUR_ACTIVECAPTION));
-	m_colorFrom   = wxColor(*wxWHITE);
-	m_activeTabColor = wxColor(*wxWHITE);
-	m_activeTextColor = wxColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNTEXT));
-	m_nonActiveTextColor = wxColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNSHADOW));
-	m_tabAreaColor = wxSystemSettings::GetColour(wxSYS_COLOUR_BTNFACE);
-
-	// Set default page height, this is done according to the system font
-	wxMemoryDC memDc;
-	wxBitmap bmp(10, 10);
-	memDc.SelectObject(bmp);
-
-	int width, height;
-
-#ifdef __WXGTK__
-	wxFont normalFont = wxSystemSettings::GetFont(wxSYS_DEFAULT_GUI_FONT);
-	wxFont boldFont = normalFont;
-	boldFont.SetWeight(wxBOLD);
-	memDc.SetFont( boldFont );
-#endif
-
-	memDc.GetTextExtent(wxT("Tp"), &width, &height);
-	int tabHeight = height + wxFNB_HEIGHT_SPACER; // We use 10 pixels as padding
-
-	wxWindow::Create(parent, id, pos, wxSize(size.x, tabHeight), style | wxNO_BORDER | wxNO_FULL_REPAINT_ON_RESIZE);
-
-	m_pDropTarget = new wxFNBDropTarget<wxPageContainer>(this, &wxPageContainer::OnDropTarget);
-	SetDropTarget(m_pDropTarget);
-}
-
-wxPageContainer::~wxPageContainer(void)
-{
-	if(m_pRightClickMenu)
-	{
-		delete m_pRightClickMenu;
-		m_pRightClickMenu = NULL;
-	}
-}
-
-void wxPageContainer::OnPaint(wxPaintEvent & event)
-{
-	wxBufferedPaintDC dc(this);
-	wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer( GetParent()->GetWindowStyleFlag() );
-
-	render->DrawTabs(this, dc, event);
-}
-
-bool wxPageContainer::AddPage(const wxString& caption, const bool selected, const int imgindex)
-{
-	if(selected)
-	{
-		m_iPreviousActivePage = m_iActivePage;
-		m_iActivePage = (int)m_pagesInfoVec.GetCount();
-	}
-
-	/// Create page info and add it to the vector
-	wxPageInfo pageInfo(caption, imgindex);
-	m_pagesInfoVec.Add(pageInfo);
-	Refresh();
-	return true;
-}
-
-bool wxPageContainer::InsertPage(size_t index, wxWindow* /*page*/, const wxString& text, bool select, const int imgindex)
-{
-	if(select)
-	{
-		m_iPreviousActivePage = m_iActivePage;
-		m_iActivePage = (int)m_pagesInfoVec.GetCount();
-	}
-	wxPageInfo pgInfo(text, imgindex);
-//	pgInfo.SetPosition(wxPoint(1, 1));
-	m_pagesInfoVec.Insert(pgInfo, index);
-	Refresh();
-	return true;
-}
-
-void wxPageContainer::OnSize(wxSizeEvent& WXUNUSED(event))
-{
-	// When resizing the control, try to fit to screen as many tabs as we we can
-	long style = GetParent()->GetWindowStyleFlag();
-	wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer(style);
-	std::vector<wxRect> vTabInfo;
-
-	int from = 0;
-	int page = GetSelection();
-	for(; from<m_nFrom; from++)
-	{
-		vTabInfo.clear();
-		render->NumberTabsCanFit( this, vTabInfo, from );
-		if(page - from >= static_cast<int>( vTabInfo.size() ))
-			continue;
-		break;
-	}
-	m_nFrom = from;
-	Refresh(); // Call on paint
-}
-
-void wxPageContainer::OnMiddleDown(wxMouseEvent& event)
-{
-	// Test if this style is enabled
-	long style = GetParent()->GetWindowStyleFlag();
-	if(!(style & wxFNB_MOUSE_MIDDLE_CLOSES_TABS))
-		return;
-
-	wxPageInfo pgInfo;
-	int tabIdx;
-	int where = HitTest(event.GetPosition(), pgInfo, tabIdx);
-	switch(where)
-	{
-	case wxFNB_TAB:
-		{
-			DeletePage((size_t)tabIdx);
-			break;
-		}
-	default:
-		break;
-	}
-	event.Skip();
-}
-
-void wxPageContainer::OnRightDown(wxMouseEvent& event)
-{
-	wxPageInfo pgInfo;
-	int tabIdx;
-	int where = HitTest(event.GetPosition(), pgInfo, tabIdx);
-	switch(where)
-	{
-	case wxFNB_TAB:
-	case wxFNB_TAB_X:
-		{
-			if(!m_pagesInfoVec[tabIdx].GetEnabled())
-				break;
-
-			// Set the current tab to be active
-			SetSelection((size_t)tabIdx);
-
-			// If the owner has defined a context menu for the tabs,
-			// popup the right click menu
-			if (m_pRightClickMenu)
-				PopupMenu(m_pRightClickMenu);
-			else
-			{
-				// send a message to popup a custom menu
-				wxFlatNotebookEvent event(wxEVT_COMMAND_FLATNOTEBOOK_CONTEXT_MENU, GetParent()->GetId());
-				event.SetSelection((int)tabIdx);
-				event.SetOldSelection((int)m_iActivePage);
-				event.SetEventObject(GetParent());
-				GetParent()->GetEventHandler()->ProcessEvent(event);
-			}
-		}
-		break;
-	default:
-		break;
-	}
-	event.Skip();
-}
-
-void wxPageContainer::OnLeftDown(wxMouseEvent& event)
-{
-	wxPageInfo pgInfo;
-	int tabIdx;
-
-	// Reset buttons status
-	m_nXButtonStatus     = wxFNB_BTN_NONE;
-	m_nLeftButtonStatus  = wxFNB_BTN_NONE;
-	m_nRightButtonStatus = wxFNB_BTN_NONE;
-	m_nTabXButtonStatus  = wxFNB_BTN_NONE;
-	m_nArrowDownButtonStatus = wxFNB_BTN_NONE;
-
-	m_nLeftClickZone = HitTest(event.GetPosition(), pgInfo, tabIdx);
-	switch(m_nLeftClickZone)
-	{
-	case wxFNB_DROP_DOWN_ARROW:
-		m_nArrowDownButtonStatus = wxFNB_BTN_PRESSED;
-		Refresh();
-		break;
-	case wxFNB_LEFT_ARROW:
-		m_nLeftButtonStatus = wxFNB_BTN_PRESSED;
-		Refresh();
-		break;
-	case wxFNB_RIGHT_ARROW:
-		m_nRightButtonStatus = wxFNB_BTN_PRESSED;
-		Refresh();
-		break;
-	case wxFNB_X:
-		m_nXButtonStatus = wxFNB_BTN_PRESSED;
-		Refresh();
-		break;
-	case wxFNB_TAB_X:
-		m_nTabXButtonStatus = wxFNB_BTN_PRESSED;
-		Refresh();
-		break;
-	case wxFNB_TAB:
-		{
-			if(m_iActivePage != tabIdx)
-			{
-				// Incase the tab is disabled, we dont allow to choose it
-				if(!m_pagesInfoVec[tabIdx].GetEnabled())
-					break;
-
-				SetSelection(tabIdx);
-			}
-			break;
-		}
-	}
-}
-
-void wxPageContainer::OnLeftUp(wxMouseEvent& event)
-{
-	wxPageInfo pgInfo;
-	int tabIdx;
-
-	// forget the zone that was initially clicked
-	m_nLeftClickZone = wxFNB_NOWHERE;
-
-	int where = HitTest(event.GetPosition(), pgInfo, tabIdx);
-	switch(where)
-	{
-	case wxFNB_LEFT_ARROW:
-		{
-			if(m_nFrom == 0)
-				break;
-
-			// Make sure that the button was pressed before
-			if(m_nLeftButtonStatus != wxFNB_BTN_PRESSED)
-				break;
-
-			m_nLeftButtonStatus = wxFNB_BTN_HOVER;
-
-			// We scroll left with bulks of 5
-			int scrollLeft = GetNumTabsCanScrollLeft();
-
-			m_nFrom -= scrollLeft;
-			if(m_nFrom < 0)
-				m_nFrom = 0;
-
-			Refresh();
-			break;
-		}
-	case wxFNB_RIGHT_ARROW:
-		{
-			if(m_nFrom >= (int)m_pagesInfoVec.GetCount() - 1)
-				break;
-
-			// Make sure that the button was pressed before
-			if(m_nRightButtonStatus != wxFNB_BTN_PRESSED)
-				break;
-
-			m_nRightButtonStatus = wxFNB_BTN_HOVER;
-
-			// Check if the right most tab is visible, if it is
-			// don't rotate right anymore
-			if(m_pagesInfoVec[m_pagesInfoVec.GetCount()-1].GetPosition() != wxPoint(-1, -1))
-				break;
-
-			int lastVisibleTab = GetLastVisibleTab();
-			if(lastVisibleTab < 0)
-			{
-				// Probably the screen is too small for displaying even a single
-				// tab, in this case we do nothing
-				break;
-			}
-
-			m_nFrom += GetNumOfVisibleTabs();
-			Refresh();
-			break;
-		}
-	case wxFNB_X:
-		{
-			// Make sure that the button was pressed before
-			if(m_nXButtonStatus != wxFNB_BTN_PRESSED)
-				break;
-
-			m_nXButtonStatus = wxFNB_BTN_HOVER;
-
-			DeletePage((size_t)m_iActivePage);
-			break;
-		}
-	case wxFNB_TAB_X:
-		{
-			// Make sure that the button was pressed before
-			if(m_nTabXButtonStatus != wxFNB_BTN_PRESSED)
-				break;
-
-			m_nTabXButtonStatus = wxFNB_BTN_HOVER;
-
-			DeletePage((size_t)m_iActivePage);
-			break;
-		}
-	case wxFNB_DROP_DOWN_ARROW:
-		{
-			// Make sure that the button was pressed before
-			if(m_nArrowDownButtonStatus != wxFNB_BTN_PRESSED)
-				break;
-
-			m_nArrowDownButtonStatus = wxFNB_BTN_NONE;
-
-			// Refresh the button status
-			wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer( GetParent()->GetWindowStyleFlag() );
-			wxClientDC dc(this);
-			render->DrawDropDownArrow(this, dc);
-
-			PopupTabsMenu();
-			break;
-		}
-	}
-}
-
-int wxPageContainer::HitTest(const wxPoint& pt, wxPageInfo& pageInfo, int &tabIdx)
-{
-	wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer( GetParent()->GetWindowStyleFlag() );
-
-	wxRect rect = GetClientRect();
-	int btnLeftPos = render->GetLeftButtonPos(this);
-	int btnRightPos = render->GetRightButtonPos(this);
-	int btnXPos =render->GetXPos(this);
-	long style = GetParent()->GetWindowStyleFlag();
-
-	tabIdx = -1;
-	if(m_pagesInfoVec.IsEmpty())
-	{
-		return wxFNB_NOWHERE;
-	}
-
-	rect = wxRect(btnXPos, 8, 16, 16);
-	if(RectContains(rect,pt))
-	{
-		return (style & wxFNB_NO_X_BUTTON) ? wxFNB_NOWHERE : wxFNB_X;
-	}
-
-	rect = wxRect(btnRightPos, 8, 16, 16);
-	if( style & wxFNB_DROPDOWN_TABS_LIST )
-	{
-		rect = wxRect(render->GetDropArrowButtonPos( this ), 8, 16, 16);
-		if( RectContains(rect,pt) )
-			return wxFNB_DROP_DOWN_ARROW;
-	}
-
-	if(RectContains(rect,pt))
-	{
-		return (style & wxFNB_NO_NAV_BUTTONS) ? wxFNB_NOWHERE : wxFNB_RIGHT_ARROW;
-	}
-
-
-	rect = wxRect(btnLeftPos, 8, 16, 16);
-	if(RectContains(rect,pt))
-	{
-		return (style & wxFNB_NO_NAV_BUTTONS) ? wxFNB_NOWHERE : wxFNB_LEFT_ARROW;
-	}
-
-	// Test whether a left click was made on a tab
-	bool bFoundMatch = false;
-	for(size_t cur=m_nFrom; cur<m_pagesInfoVec.GetCount(); cur++)
-	{
-		wxPageInfo pgInfo = m_pagesInfoVec[cur];
-		if(pgInfo.GetPosition() == wxPoint(-1, -1))
-			continue;
-
-		// check for mouse over tab's x button
-		if(style & wxFNB_X_ON_TAB && (int)cur == GetSelection())
-		{
-			// 'x' button exists on a tab
-			if(RectContains(m_pagesInfoVec[cur].GetXRect(),pt))
-			{
-				pageInfo = pgInfo;
-				tabIdx = (int)cur;
-				return wxFNB_TAB_X;
-			}
-		}
-
-		if(style & wxFNB_VC8)
-		{
-			if(m_pagesInfoVec[cur].GetRegion().Contains(pt) == wxInRegion)
-			{
-				if(bFoundMatch || (int)cur == GetSelection())
-				{
-					pageInfo = pgInfo;
-					tabIdx = (int)cur;
-					return wxFNB_TAB;
-				}
-				pageInfo = pgInfo;
-				tabIdx = (int)cur;
-				bFoundMatch = true;
-			}
-		}
-		else
-		{
-
-			wxRect tabRect = wxRect(pgInfo.GetPosition().x, pgInfo.GetPosition().y,
-				pgInfo.GetSize().x, pgInfo.GetSize().y);
-			if(RectContains(tabRect,pt))
-			{
-				// We have a match
-				pageInfo = pgInfo;
-				tabIdx = (int)cur;
-				return wxFNB_TAB;
-			}
-		}
-	}
-
-	if(bFoundMatch)
-		return wxFNB_TAB;
-
-	// Default
-	return wxFNB_NOWHERE;
-}
-
-void wxPageContainer::SetSelection(size_t page)
-{
-	wxFlatNotebook* book = (wxFlatNotebook*)GetParent();
-	book->SetSelection(page);
-	DoSetSelection(page);
-}
-
-void wxPageContainer::DoSetSelection(size_t page)
-{
-	// Make sure that the selection is visible
-	if(page < m_pagesInfoVec.GetCount())
-	{
-		//! fix for tabfocus
-		wxWindow* da_page = ((wxFlatNotebook *)m_pParent)->GetPage(page);
-		if ( da_page!=NULL )
-			da_page->SetFocus();
-	}
-
-	if( !IsTabVisible(page) )
-	{
-		FNB_LOG_MSG( wxT("Tab ") << (int)page << wxT(" is not visible"));
-		FNB_LOG_MSG( wxT("m_nFrom=") << m_nFrom << wxT(", Selection=") << (int)page );
-
-		// Try to remove one tab from start and try again
-		if( !CanFitToScreen(page) )
-		{
-			if( m_nFrom > (int)page )
-				m_nFrom = (int)page;
-			else
-			{
-				while( m_nFrom < (int)page )
-				{
-					m_nFrom++;
-					if( CanFitToScreen(page) )
-						break;
-				}
-			}
-			FNB_LOG_MSG( wxT("Adjusting m_nFrom to=") << m_nFrom);
-		}
-	}
-	else
-	{
-		FNB_LOG_MSG( wxT("Tab ") << (int)page << wxT(" is visible"));
-	}
-	Refresh();
-}
-
-void wxPageContainer::DeletePage(size_t page)
-{
-	wxFlatNotebook* book = (wxFlatNotebook*)GetParent();
-	book->DeletePage(page);
-	book->Refresh();
-}
-
-bool wxPageContainer::IsTabVisible(size_t page)
-{
-	int iPage = (int)page;
-	int iLastVisiblePage = GetLastVisibleTab();
-
-	return iPage <= iLastVisiblePage && iPage >= m_nFrom;
-}
-
-void wxPageContainer::DoDeletePage(size_t page)
-{
-	// Remove the page from the vector
-	wxFlatNotebook* book = (wxFlatNotebook*)GetParent();
-	m_pagesInfoVec.RemoveAt(page);
-
-	// Thanks to Yiannis AKA Mandrav
-	if (m_iActivePage >= (int)page)
-	{
-		m_iActivePage--;
-		m_iPreviousActivePage = -1;
-	}
-
-	// The delete page was the last first on the array,
-	// but the book still has more pages, so we set the
-	// active page to be the first one (0)
-	if(m_iActivePage < 0 && !m_pagesInfoVec.empty())
-	{
-		m_iPreviousActivePage = -1;
-		m_iActivePage = 0;
-	}
-
-	// Refresh the tabs
-	if(m_iActivePage >= 0)
-	{
-		book->m_bForceSelection = true;
-		book->SetSelection(m_iActivePage);
-		book->m_bForceSelection = false;
-	}
-
-	if(m_pagesInfoVec.empty())
-	{
-		// Erase the page container drawings
-		wxClientDC dc(this);
-		dc.Clear();
-	}
-}
-
-void wxPageContainer::DeleteAllPages()
-{
-	m_iActivePage = -1;
-	m_iPreviousActivePage = -1;
-	m_nFrom = 0;
-	m_pagesInfoVec.Clear();
-
-	// Erase the page container drawings
-	wxClientDC dc(this);
-	dc.Clear();
-}
-
-void wxPageContainer::OnMouseMove(wxMouseEvent& event)
-{
-	if (!m_pagesInfoVec.empty() && IsShown())
-	{
-		const int xButtonStatus = m_nXButtonStatus;
-		const int xTabButtonStatus = m_nTabXButtonStatus;
-		const int rightButtonStatus = m_nRightButtonStatus;
-		const int leftButtonStatus = m_nLeftButtonStatus;
-		const int dropDownButtonStatus = m_nArrowDownButtonStatus;
-
-		long style = GetParent()->GetWindowStyleFlag();
-
-		m_nXButtonStatus = wxFNB_BTN_NONE;
-		m_nRightButtonStatus = wxFNB_BTN_NONE;
-		m_nLeftButtonStatus = wxFNB_BTN_NONE;
-		m_nTabXButtonStatus = wxFNB_BTN_NONE;
-		m_nArrowDownButtonStatus = wxFNB_BTN_NONE;
-
-		wxPageInfo pgInfo;
-		int tabIdx;
-
-		int where = HitTest(event.GetPosition(), pgInfo, tabIdx);
-		switch ( where )
-		{
-		case wxFNB_X:
-			if (event.LeftIsDown())
-			{
-				m_nXButtonStatus = (m_nLeftClickZone==wxFNB_X) ? wxFNB_BTN_PRESSED : wxFNB_BTN_NONE;
-			}
-			else
-			{
-				m_nXButtonStatus = wxFNB_BTN_HOVER;
-			}
-			break;
-		case wxFNB_DROP_DOWN_ARROW:
-			if (event.LeftIsDown())
-			{
-				m_nArrowDownButtonStatus = (m_nLeftClickZone == wxFNB_DROP_DOWN_ARROW) ? wxFNB_BTN_PRESSED : wxFNB_BTN_NONE;
-			}
-			else
-			{
-				m_nArrowDownButtonStatus = wxFNB_BTN_HOVER;
-			}
-			break;
-		case wxFNB_TAB_X:
-			if (event.LeftIsDown())
-			{
-				m_nTabXButtonStatus = (m_nLeftClickZone==wxFNB_TAB_X) ? wxFNB_BTN_PRESSED : wxFNB_BTN_NONE;
-			}
-			else
-			{
-				m_nTabXButtonStatus = wxFNB_BTN_HOVER;
-			}
-			break;
-		case wxFNB_RIGHT_ARROW:
-			if (event.LeftIsDown())
-			{
-				m_nRightButtonStatus = (m_nLeftClickZone==wxFNB_RIGHT_ARROW) ? wxFNB_BTN_PRESSED : wxFNB_BTN_NONE;
-			}
-			else
-			{
-				m_nRightButtonStatus = wxFNB_BTN_HOVER;
-			}
-			break;
-
-		case wxFNB_LEFT_ARROW:
-			if (event.LeftIsDown())
-			{
-				m_nLeftButtonStatus = (m_nLeftClickZone==wxFNB_LEFT_ARROW) ? wxFNB_BTN_PRESSED : wxFNB_BTN_NONE;
-			}
-			else
-			{
-				m_nLeftButtonStatus = wxFNB_BTN_HOVER;
-			}
-			break;
-
-		case wxFNB_TAB:
-			// Call virtual method for showing tooltip
-			ShowTabTooltip(tabIdx);
-			if(!GetEnabled((size_t)tabIdx))
-			{
-				// Set the cursor to be 'No-entry'
-				::wxSetCursor(wxCURSOR_NO_ENTRY);
-			}
-
-			// Support for drag and drop
-			if(event.Dragging() && !(style & wxFNB_NODRAG))
-			{
-				wxFNBDragInfo draginfo(this, tabIdx);
-				wxFNBDragInfoDataObject dataobject(wxDataFormat(wxT("wxFNB")));
-				dataobject.SetData(sizeof(wxFNBDragInfo), &draginfo);
-				wxFNBDropSource dragSource(this);
-				dragSource.SetData(dataobject);
-				dragSource.DoDragDrop(wxDrag_DefaultMove);
-			}
-			break;
-		default:
-			m_nTabXButtonStatus = wxFNB_BTN_NONE;
-			break;
-		}
-
-		const bool bRedrawX = m_nXButtonStatus != xButtonStatus;
-		const bool bRedrawDropArrow = m_nArrowDownButtonStatus != dropDownButtonStatus;
-		const bool bRedrawRight = m_nRightButtonStatus != rightButtonStatus;
-		const bool bRedrawLeft = m_nLeftButtonStatus != leftButtonStatus;
-		const bool bRedrawTabX = m_nTabXButtonStatus != xTabButtonStatus;
-
-		wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer( GetParent()->GetWindowStyleFlag() );
-
-		if (bRedrawX || bRedrawRight || bRedrawLeft || bRedrawTabX || bRedrawDropArrow)
-		{
-			wxClientDC dc(this);
-			if (bRedrawX)
-			{
-				render->DrawX(this, dc);
-			}
-			if (bRedrawLeft)
-			{
-				render->DrawLeftArrow(this, dc);
-			}
-			if (bRedrawRight)
-			{
-				render->DrawRightArrow(this, dc);
-			}
-			if (bRedrawTabX)
-			{
-				FNB_LOG_MSG( wxT("Refreshing Tab 'X' button with status=") << m_nTabXButtonStatus << wxT(" and tabIdx=") << tabIdx );
-				render->DrawTabX(this, dc, pgInfo.GetXRect(), tabIdx, m_nTabXButtonStatus);
-			}
-			if (bRedrawDropArrow)
-			{
-				render->DrawDropDownArrow(this, dc);
-			}
-		}
-	}
-	event.Skip();
-}
-
-int wxPageContainer::GetLastVisibleTab()
-{
-	int i;
-	if( m_nFrom < 0)
-		return -1;
-
-	for(i=m_nFrom; i<(int)m_pagesInfoVec.GetCount(); i++)
-	{
-		if(m_pagesInfoVec[i].GetPosition() == wxPoint(-1, -1))
-			break;
-	}
-	return (i-1);
-}
-
-int wxPageContainer::GetNumTabsCanScrollLeft()
-{
-	int i;
-
-	// Reserved area for the buttons (<>x)
-	wxRect rect = GetClientRect();
-	int clientWidth = rect.width;
-	int posx = ((wxFlatNotebook *)m_pParent)->m_nPadding, numTabs = 0, tabHeight, tabWidth;
-
-	wxClientDC dc(this);
-
-	// Incase we have error prevent crash
-	if(m_nFrom < 0)
-		return 0;
-
-	long style = GetParent()->GetWindowStyleFlag();
-	wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer(style);
-
-	tabHeight = render->CalcTabHeight(this);
-	for(i=m_nFrom; i>=0; i--)
-	{
-		tabWidth = render->CalcTabWidth(this, i, tabHeight);
-		if(posx + tabWidth + render->GetButtonsAreaLength(this) >= clientWidth)
-			break;
-
-		numTabs++;
-		posx += tabWidth;
-	}
-	return numTabs;
-}
-
-bool wxPageContainer::IsDefaultTabs()
-{
-	long style = GetParent()->GetWindowStyleFlag();
-	bool res = (style & wxFNB_VC71) || (style & wxFNB_FANCY_TABS) || (style & wxFNB_VC8);
-	return !res;
-}
-
-void wxPageContainer::AdvanceSelection(bool bForward)
-{
-	int nSel = GetSelection();
-
-	if(nSel < 0)
-		return;
-
-	int nMax = (int)GetPageCount() - 1;
-	if ( bForward )
-		SetSelection(nSel == nMax ? 0 : nSel + 1);
-	else
-		SetSelection(nSel == 0 ? nMax : nSel - 1);
-}
-
-
-void wxPageContainer::OnMouseLeave(wxMouseEvent& event)
-{
-	m_nLeftButtonStatus = wxFNB_BTN_NONE;
-	m_nXButtonStatus = wxFNB_BTN_NONE;
-	m_nRightButtonStatus = wxFNB_BTN_NONE;
-	m_nTabXButtonStatus = wxFNB_BTN_NONE;
-	m_nArrowDownButtonStatus = wxFNB_BTN_NONE;
-
-	long style = GetParent()->GetWindowStyleFlag();
-	wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer(style);
-
-	wxClientDC dc(this);
-	render->DrawX(this, dc);
-	render->DrawLeftArrow(this, dc);
-	render->DrawRightArrow(this, dc);
-	if(GetSelection() != -1 && IsTabVisible((size_t)GetSelection()))
-	{
-		render->DrawTabX(this, dc, m_pagesInfoVec[GetSelection()].GetXRect(), GetSelection(), m_nTabXButtonStatus);
-	}
-
-	event.Skip();
-}
-
-void wxPageContainer::OnMouseEnterWindow(wxMouseEvent& event)
-{
-	m_nLeftButtonStatus = wxFNB_BTN_NONE;
-	m_nXButtonStatus = wxFNB_BTN_NONE;
-	m_nRightButtonStatus = wxFNB_BTN_NONE;
-	m_nLeftClickZone = wxFNB_BTN_NONE;
-	m_nArrowDownButtonStatus = wxFNB_BTN_NONE;
-
-	event.Skip();
-}
-
-void wxPageContainer::ShowTabTooltip(int tabIdx)
-{
-	wxWindow *pWindow = ((wxFlatNotebook *)m_pParent)->GetPage(tabIdx);
-	if( pWindow )
-	{
-		wxToolTip *pToolTip = pWindow->GetToolTip();
-		if(pToolTip && pToolTip->GetWindow() == pWindow)
-			SetToolTip(pToolTip->GetTip());
-	}
-}
-
-void wxPageContainer::SetPageImageIndex(size_t page, int imgindex)
-{
-	if(page < m_pagesInfoVec.GetCount())
-	{
-		m_pagesInfoVec[page].SetImageIndex(imgindex);
-		Refresh();
-	}
-}
-
-int wxPageContainer::GetPageImageIndex(size_t page)
-{
-	if(page < m_pagesInfoVec.GetCount())
-	{
-		return m_pagesInfoVec[page].GetImageIndex();
-	}
-	return -1;
-}
-
-wxDragResult wxPageContainer::OnDropTarget(wxCoord x, wxCoord y, int nTabPage, wxWindow * wnd_oldContainer)
-{
-	// Disable drag'n'drop for disabled tab
-	if(!((wxPageContainer *)wnd_oldContainer)->m_pagesInfoVec[nTabPage].GetEnabled())
-		return wxDragCancel;
-
-	wxLogTrace(wxTraceMask(), _("Old Page Index = %i"), nTabPage);
-	wxPageContainer * oldContainer = (wxPageContainer *)wnd_oldContainer;
-	int nIndex = -1;
-	wxPageInfo pgInfo;
-	int where = HitTest(wxPoint(x, y), pgInfo, nIndex);
-	wxLogTrace(wxTraceMask(), _("OnDropTarget: index by HitTest = %i"), nIndex);
-	wxFlatNotebook * oldNotebook = (wxFlatNotebook *)oldContainer->GetParent();
-	wxFlatNotebook * newNotebook = (wxFlatNotebook *)GetParent();
-
-	if(oldNotebook == newNotebook)
-	{
-		if(nTabPage >= 0)
-		{
-			switch(where)
-			{
-			case wxFNB_TAB:
-				MoveTabPage(nTabPage, nIndex);
-				break;
-			case wxFNB_NOWHERE:
-				{
-				}
-				break;
-			default:
-				break;
-			}
-		}
-	}
-	else if ( GetParent()->GetWindowStyleFlag() & wxFNB_ALLOW_FOREIGN_DND )
-	{
-#if defined(__WXMSW__) || defined(__WXGTK__)
-		if(nTabPage >= 0)
-		{
-			wxWindow * window = oldNotebook->GetPage(nTabPage);
-			if(window)
-			{
-				wxString caption = oldContainer->GetPageText(nTabPage);
-
-				// Pass the image to the new container
-				// incase that the new container (this) does not have image list we dont pass the image
-				// to the new notebook
-				int newIndx( wxNOT_FOUND );
-
-				if( m_ImageList )
-				{
-					int imageindex = oldContainer->GetPageImageIndex(nTabPage);
-					if( imageindex >= 0 )
-					{
-						wxBitmap bmp( (*oldContainer->GetImageList())[imageindex] );
-						m_ImageList->Add( bmp );
-						newIndx = static_cast<int>(m_ImageList->GetCount() - 1);
-					}
-				}
-
-				oldNotebook->RemovePage( nTabPage );
-				window->Reparent( newNotebook );
-				newNotebook->InsertPage(nIndex, window, caption, true, newIndx);
-			}
-		}
-#endif
-	}
-	return wxDragMove;
-}
-
-void wxPageContainer::MoveTabPage(int nMove, int nMoveTo)
-{
-	if(nMove == nMoveTo)
-		return;
-
-	else if(nMoveTo < (int)((wxFlatNotebook *)m_pParent)->m_windows.GetCount())
-		nMoveTo++;
-
-	m_pParent->Freeze();
-	// Remove the window from the main sizer
-	int nCurSel = ((wxFlatNotebook *)m_pParent)->m_pages->GetSelection();
-	((wxFlatNotebook *)m_pParent)->m_mainSizer->Detach(((wxFlatNotebook *)m_pParent)->m_windows[nCurSel]);
-	((wxFlatNotebook *)m_pParent)->m_windows[nCurSel]->Hide();
-
-	wxWindow *pWindow = ((wxFlatNotebook *)m_pParent)->m_windows[nMove];
-	((wxFlatNotebook *)m_pParent)->m_windows.RemoveAt(nMove);
-	((wxFlatNotebook *)m_pParent)->m_windows.Insert(pWindow, nMoveTo-1);
-
-	wxPageInfo pgInfo = m_pagesInfoVec[nMove];
-
-	m_pagesInfoVec.RemoveAt( nMove );
-	m_pagesInfoVec.Insert(pgInfo, nMoveTo - 1);
-
-	// Add the page according to the style
-	wxBoxSizer* pSizer = ((wxFlatNotebook *)m_pParent)->m_mainSizer;
-	long style = GetParent()->GetWindowStyleFlag();
-
-
-	if(style & wxFNB_BOTTOM)
-	{
-		pSizer->Insert(0, pWindow, 1, wxEXPAND);
-	}
-	else
-	{
-		// We leave a space of 1 pixel around the window
-		pSizer->Add(pWindow, 1, wxEXPAND);
-	}
-	pWindow->Show();
-
-	pSizer->Layout();
-	m_iActivePage = nMoveTo-1;
-	m_iPreviousActivePage = -1;
-	DoSetSelection(m_iActivePage);
-	Refresh();
-	m_pParent->Thaw();
-}
-
-bool wxPageContainer::CanFitToScreen(size_t page)
-{
-	// Incase the from is greater than page,
-	// we need to reset the m_nFrom, so in order
-	// to force the caller to do so, we return false
-	if(m_nFrom > (int)page)
-		return false;
-
-	long style = GetParent()->GetWindowStyleFlag();
-	wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer(style);
-	std::vector<wxRect> vTabInfo;
-	render->NumberTabsCanFit( this, vTabInfo );
-
-	if(static_cast<int>(page) - m_nFrom >= static_cast<int>( vTabInfo.size() ))
-		return false;
-	return true;
-}
-
-int wxPageContainer::GetNumOfVisibleTabs()
-{
-	int i=m_nFrom;
-	int counter = 0;
-	for(; i<(int)m_pagesInfoVec.GetCount(); i++, ++counter)
-	{
-		if(m_pagesInfoVec[i].GetPosition() == wxPoint(-1, -1))
-			break;
-	}
-	return counter;
-}
-
-bool wxPageContainer::GetEnabled(size_t page)
-{
-	if(page >= m_pagesInfoVec.GetCount())
-		return true;	// Seems strange, but this is the default
-	return m_pagesInfoVec[page].GetEnabled();
-}
-
-void wxPageContainer::Enable(size_t page, bool enabled)
-{
-	if(page >= m_pagesInfoVec.GetCount())
-		return ;
-    m_pagesInfoVec[page].Enable(enabled);
-    return;
-}
-
-wxColor wxPageContainer::GetSingleLineBorderColor()
-{
-	if(HasFlag(wxFNB_FANCY_TABS))
-		return m_colorFrom;
-	return *wxWHITE;
-}
-
-bool wxPageContainer::HasFlag(int flag)
-{
-	long style = GetParent()->GetWindowStyleFlag();
-	bool res = style & flag ? true : false;
-	return res;
-}
-
-void wxPageContainer::ClearFlag(int flag)
-{
-	long style = GetParent()->GetWindowStyleFlag();
-	style &= ~( flag );
-	wxWindowBase::SetWindowStyleFlag(style);
-}
-
-bool wxPageContainer::TabHasImage(int tabIdx)
-{
-	if(m_ImageList)
-		return m_pagesInfoVec[tabIdx].GetImageIndex() != -1;
-	return false;
-}
-
-void wxPageContainer::OnLeftDClick(wxMouseEvent& event)
-{
-	wxPageInfo pgInfo;
-	int tabIdx;
-	int where = HitTest(event.GetPosition(), pgInfo, tabIdx);
-	switch(where)
-	{
-	case wxFNB_TAB:
-		if(HasFlag(wxFNB_DCLICK_CLOSES_TABS))
-		{
-			{
-				DeletePage((size_t)tabIdx);
-				break;
-			}
-		}
-	case wxFNB_X:
-		{
-			OnLeftDown(event);
-			break;
-		}
-	default:
-		event.Skip();
-		break;
-	}
-}
-
-void wxPageContainer::PopupTabsMenu()
-{
-	wxMenu popupMenu;
-
-	for(size_t i=0; i<m_pagesInfoVec.GetCount(); i++)
-	{
-		wxPageInfo pi = m_pagesInfoVec[i];
-		wxMenuItem *item = new wxMenuItem(&popupMenu, static_cast<int>(i), pi.GetCaption(), pi.GetCaption(), wxITEM_NORMAL);
-
-		// This code is commented, since there is an alignment problem with wx2.6.3 & Menus
-//		if( TabHasImage(static_cast<int>(i)) )
-//			item->SetBitmaps( (*m_ImageList)[pi.GetImageIndex()] );
-
-		popupMenu.Append( item );
-	}
-
-	// connect an event handler to our menu
-	popupMenu.Connect(wxID_ANY, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(wxPageContainer::OnTabMenuSelection), NULL, this);
-	PopupMenu( &popupMenu );
-}
-
-void wxPageContainer::OnTabMenuSelection(wxCommandEvent &event)
-{
-	int selection = event.GetId();
-	static_cast<wxFlatNotebook*>(m_pParent)->SetSelection( (size_t)selection );
-}
-
-// Draw small arrow at the place that the tab will be placed
-void wxPageContainer::DrawDragHint()
-{
-	// get the index of tab that will be replaced with the dragged tab
-	wxPageInfo info;
-	int tabIdx;
-	wxPoint pt = ::wxGetMousePosition();
-    wxPoint client_pt = ScreenToClient(pt);
-	HitTest(client_pt, info, tabIdx);
-	wxFNBRendererMgrST::Get()->GetRenderer( GetParent()->GetWindowStyleFlag() )->DrawDragHint(this, tabIdx);
-}
+		GetEventHandler()->ProcessEvent(event);
+
+		if( !event.IsAllowed() )
+		{
+			return;
+		}
+	}
+
+	int curSel = m_pages->GetSelection();
+
+	// program allows the page change
+	Freeze();
+	if(curSel >= 0)
+	{
+		// Remove the window from the main sizer
+		m_mainSizer->Detach(m_windows[curSel]);
+		m_windows[curSel]->Hide();
+	}
+
+	if(m_windowStyle & wxFNB_BOTTOM)
+	{
+		m_mainSizer->Insert(0, m_windows[page], 1, wxEXPAND);
+	}
+	else
+	{
+		// We leave a space of 1 pixel around the window
+		m_mainSizer->Add(m_windows[page], 1, wxEXPAND);
+	}
+
+	m_windows[page]->Show();
+	Thaw();
+	m_mainSizer->Layout();
+
+	if( page != (size_t)m_pages->m_iActivePage )
+		//there is a real poge changing
+		m_pages->m_iPreviousActivePage = m_pages->m_iActivePage;
+
+	m_pages->m_iActivePage = (int)page;
+	m_pages->DoSetSelection(page);
+
+	if( m_sendPageChangeEvent )
+	{
+		// Fire event 'Page Changed'
+		wxFlatNotebookEvent event(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CHANGED, GetId());
+		event.SetSelection( (int)page );
+		event.SetEventObject( this );
+		GetEventHandler()->ProcessEvent(event);
+	}
+}
+
+void wxFlatNotebook::DeletePage(size_t page, bool notify)
+{
+	if(page >= m_windows.GetCount())
+		return;
+
+	// Fire a closing event
+	if( notify )
+	{
+		wxFlatNotebookEvent event(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSING, GetId());
+		event.SetSelection((int)page);
+		event.SetEventObject(this);
+		GetEventHandler()->ProcessEvent(event);
+
+
+		// The event handler allows it?
+		if (!event.IsAllowed())
+			return;
+	}
+
+	Freeze();
+
+	// Delete the requested page
+	wxWindow *pageRemoved = m_windows[page];
+
+	// If the page is the current window, remove it from the sizer
+	// as well
+	if((int)page == m_pages->GetSelection())
+	{
+		m_mainSizer->Detach(pageRemoved);
+	}
+
+	// Remove it from the array as well
+	m_windows.RemoveAt(page);
+
+	// Now we can destroy it; in wxWidgets use Destroy instead of delete
+	pageRemoved->Destroy();
+
+	Thaw();
+
+	m_pages->DoDeletePage(page);
+	Refresh();
+
+	// Fire a closed event
+	if( notify )
+	{
+		wxFlatNotebookEvent closedEvent(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSED, GetId());
+		closedEvent.SetSelection((int)page);
+		closedEvent.SetEventObject(this);
+		GetEventHandler()->ProcessEvent(closedEvent);
+	}
+}
+
+bool wxFlatNotebook::DeleteAllPages()
+{
+	if(m_windows.empty())
+		return false;
+
+	Freeze();
+	int i = 0;
+	for(; i<(int)m_windows.GetCount(); i++)
+	{
+		delete m_windows[i];
+	}
+
+	m_windows.Clear();
+	Thaw();
+
+	// Clear the container of the tabs as well
+	m_pages->DeleteAllPages();
+	return true;
+}
+
+wxWindow* wxFlatNotebook::GetCurrentPage() const
+{
+	int sel = m_pages->GetSelection();
+	if(sel < 0)
+		return NULL;
+
+	return m_windows[sel];
+}
+
+wxWindow* wxFlatNotebook::GetPage(size_t page) const
+{
+	if(page >= m_windows.GetCount())
+		return NULL;
+
+	return m_windows[page];
+}
+
+int wxFlatNotebook::GetPageIndex(wxWindow* win) const
+{
+	for (size_t i = 0; i < m_windows.GetCount(); ++i)
+	{
+		if (m_windows[i] == win)
+			return (int)i;
+	}
+	return -1;
+}
+
+int wxFlatNotebook::GetSelection() const
+{
+	return m_pages->GetSelection();
+}
+
+void wxFlatNotebook::AdvanceSelection(bool bForward)
+{
+	m_pages->AdvanceSelection(bForward);
+}
+
+int wxFlatNotebook::GetPageCount() const
+{
+	return (int)m_pages->GetPageCount();
+}
+
+void wxFlatNotebook::OnNavigationKey(wxNavigationKeyEvent& event)
+{
+	if ( event.IsWindowChange() )
+	{
+		if( HasFlag(wxFNB_SMART_TABS) )
+		{
+			if( !m_popupWin )
+			{
+				m_popupWin = new wxTabNavigatorWindow( this );
+				m_popupWin->ShowModal();
+				m_popupWin->Destroy();
+				m_popupWin = NULL;
+			}
+			else
+			{
+				// a dialog is already opened
+				m_popupWin->OnNavigationKey( event );
+				return;
+			}
+		}
+		else
+		{
+			// change pages
+			AdvanceSelection(event.GetDirection());
+		}
+	}
+	else
+	{
+		// pass to the parent
+		if ( GetParent() )
+		{
+			event.SetCurrentFocus(this);
+			GetParent()->ProcessEvent(event);
+		}
+	}
+}
+
+bool wxFlatNotebook::GetPageShapeAngle(int page_index, unsigned int * result)
+{
+	if(page_index < 0 || page_index >= (int)m_pages->m_pagesInfoVec.GetCount()) return false;
+	*result = m_pages->m_pagesInfoVec[page_index].GetTabAngle();
+	return true;
+}
+
+void wxFlatNotebook::SetPageShapeAngle(int page_index, unsigned int angle)
+{
+	if(page_index < 0 || page_index >= (int)m_pages->m_pagesInfoVec.GetCount()) return;
+	if(angle > 15) return;
+
+	m_pages->m_pagesInfoVec[page_index].SetTabAngle(angle);
+}
+
+void wxFlatNotebook::SetAllPagesShapeAngle(unsigned int angle)
+{
+	if(angle > 15) return;
+	for(unsigned int i = 0; i < m_pages->m_pagesInfoVec.GetCount(); i++)
+	{
+		m_pages->m_pagesInfoVec[i].SetTabAngle(angle);
+	}
+	Refresh();
+}
+
+wxSize wxFlatNotebook::GetPageBestSize()
+{
+	return m_pages->GetClientSize();
+}
+
+bool wxFlatNotebook::SetPageText(size_t page, const wxString& text)
+{
+	bool bVal = m_pages->SetPageText(page, text);
+	m_pages->Refresh();
+	return bVal;
+}
+
+void wxFlatNotebook::SetPadding(const wxSize& padding)
+{
+	m_nPadding = padding.GetWidth();
+}
+
+void wxFlatNotebook::SetWindowStyleFlag(long style)
+{
+	wxPanel::SetWindowStyleFlag(style);
+
+	if(m_pages)
+	{
+		// For changing the tab position (i.e. placing them top/bottom)
+		// refreshing the tab container is not enough
+		m_sendPageChangeEvent = false;
+		SetSelection(m_pages->m_iActivePage);
+		m_sendPageChangeEvent = true;
+	}
+}
+
+bool wxFlatNotebook::RemovePage(size_t page, bool notify)
+{
+	if(page >= m_windows.GetCount())
+		return false;
+
+	// Fire a closing event
+	if( notify )
+	{
+		wxFlatNotebookEvent event(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSING, GetId());
+		event.SetSelection((int)page);
+		event.SetEventObject(this);
+		GetEventHandler()->ProcessEvent(event);
+
+		// The event handler allows it?
+		if (!event.IsAllowed())
+			return false;
+	}
+
+	Freeze();
+
+	// Remove the requested page
+	wxWindow *pageRemoved = m_windows[page];
+
+	// If the page is the current window, remove it from the sizer
+	// as well
+	if((int)page == m_pages->GetSelection())
+	{
+		m_mainSizer->Detach(pageRemoved);
+	}
+
+	// Remove it from the array as well
+	m_windows.RemoveAt(page);
+	Thaw();
+
+	m_pages->DoDeletePage(page);
+
+	// Fire a closed event
+	if( notify )
+	{
+		wxFlatNotebookEvent closedEvent(wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSED, GetId());
+		closedEvent.SetSelection((int)page);
+		closedEvent.SetEventObject(this);
+		GetEventHandler()->ProcessEvent(closedEvent);
+	}
+	return true;
+}
+
+void wxFlatNotebook::SetRightClickMenu(wxMenu* menu)
+{
+	m_pages->m_pRightClickMenu = menu;
+}
+
+wxString wxFlatNotebook::GetPageText(size_t page)
+{
+	return m_pages->GetPageText(page);
+}
+
+void wxFlatNotebook::SetGradientColors(const wxColour& from, const wxColour& to, const wxColour& border)
+{
+	m_pages->m_colorFrom = from;
+	m_pages->m_colorTo   = to;
+	m_pages->m_colorBorder = border;
+}
+
+void wxFlatNotebook::SetGradientColorFrom(const wxColour& from)
+{
+	m_pages->m_colorFrom = from;
+}
+
+void wxFlatNotebook::SetGradientColorTo(const wxColour& to)
+{
+	m_pages->m_colorTo   = to;
+}
+
+void wxFlatNotebook::SetGradientColorBorder(const wxColour& border)
+{
+	m_pages->m_colorBorder = border;
+}
+
+/// Gets first gradient colour
+const wxColour& wxFlatNotebook::GetGradientColorFrom()
+{
+	return m_pages->m_colorFrom;
+}
+
+/// Gets second gradient colour
+const wxColour& wxFlatNotebook::GetGradientColorTo()
+{
+	return m_pages->m_colorTo;
+}
+
+/// Gets the tab border colour
+const wxColour& wxFlatNotebook::SetGradientColorBorder()
+{
+	return m_pages->m_colorBorder;
+}
+
+/// Get the active tab text
+const wxColour& wxFlatNotebook::GetActiveTabTextColour()
+{
+	return m_pages->m_activeTextColor;
+}
+
+void wxFlatNotebook::SetPageImageIndex(size_t page, int imgindex)
+{
+	m_pages->SetPageImageIndex(page, imgindex);
+}
+
+int wxFlatNotebook::GetPageImageIndex(size_t page)
+{
+	return m_pages->GetPageImageIndex(page);
+}
+
+bool wxFlatNotebook::GetEnabled(size_t page)
+{
+	return m_pages->GetEnabled(page);
+}
+
+void wxFlatNotebook::Enable(size_t page, bool enabled)
+{
+	if(page >= m_windows.GetCount())
+		return;
+
+	m_windows[page]->Enable(enabled);
+	m_pages->Enable(page, enabled);
+}
+
+const wxColour& wxFlatNotebook::GetNonActiveTabTextColour()
+{
+	return m_pages->m_nonActiveTextColor;
+}
+
+void wxFlatNotebook::SetNonActiveTabTextColour(const wxColour& color)
+{
+	m_pages->m_nonActiveTextColor = color;
+}
+
+void wxFlatNotebook::SetTabAreaColour(const wxColour& color)
+{
+	m_pages->m_tabAreaColor = color;
+}
+
+const wxColour& wxFlatNotebook::GetTabAreaColour()
+{
+	return m_pages->m_tabAreaColor;
+}
+
+void wxFlatNotebook::SetActiveTabColour(const wxColour& color)
+{
+	m_pages->m_activeTabColor = color;
+}
+
+const wxColour& wxFlatNotebook::GetActiveTabColour()
+{
+	return m_pages->m_activeTabColor;
+}
+
+///////////////////////////////////////////////////////////////////////////////////////////
+//
+//	wxPageContainer
+//
+///////////////////////////////////////////////////////////////////////////////////////////
+
+BEGIN_EVENT_TABLE(wxPageContainer, wxPanel)
+EVT_PAINT(wxPageContainer::OnPaint)
+EVT_SIZE(wxPageContainer::OnSize)
+EVT_LEFT_DOWN(wxPageContainer::OnLeftDown)
+EVT_LEFT_UP(wxPageContainer::OnLeftUp)
+EVT_RIGHT_DOWN(wxPageContainer::OnRightDown)
+EVT_MIDDLE_DOWN(wxPageContainer::OnMiddleDown)
+EVT_MOTION(wxPageContainer::OnMouseMove)
+EVT_ERASE_BACKGROUND(wxPageContainer::OnEraseBackground)
+EVT_LEAVE_WINDOW(wxPageContainer::OnMouseLeave)
+EVT_ENTER_WINDOW(wxPageContainer::OnMouseEnterWindow)
+EVT_LEFT_DCLICK(wxPageContainer::OnLeftDClick)
+END_EVENT_TABLE()
+
+wxPageContainer::wxPageContainer(wxWindow* parent, wxWindowID id, const wxPoint& pos, const wxSize& size, long style)
+: m_ImageList(NULL)
+, m_iActivePage(-1)
+, m_pDropTarget(NULL)
+, m_nLeftClickZone(wxFNB_NOWHERE)
+, m_iPreviousActivePage(-1)
+{
+	m_pRightClickMenu = NULL;
+	m_nXButtonStatus = wxFNB_BTN_NONE;
+	m_nArrowDownButtonStatus = wxFNB_BTN_NONE;
+	m_pParent = parent;
+	m_nRightButtonStatus = wxFNB_BTN_NONE;
+	m_nLeftButtonStatus = wxFNB_BTN_NONE;
+	m_nTabXButtonStatus = wxFNB_BTN_NONE;
+
+	m_colorTo = wxColour(wxSystemSettings::GetColour(wxSYS_COLOUR_ACTIVECAPTION));
+	m_colorFrom   = wxColor(*wxWHITE);
+	m_activeTabColor = wxColor(*wxWHITE);
+	m_activeTextColor = wxColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNTEXT));
+	m_nonActiveTextColor = wxColour(wxSystemSettings::GetColour(wxSYS_COLOUR_BTNSHADOW));
+	m_tabAreaColor = wxSystemSettings::GetColour(wxSYS_COLOUR_BTNFACE);
+
+	// Set default page height, this is done according to the system font
+	wxMemoryDC memDc;
+	wxBitmap bmp(10, 10);
+	memDc.SelectObject(bmp);
+
+	int width, height;
+
+#ifdef __WXGTK__
+	wxFont normalFont = wxSystemSettings::GetFont(wxSYS_DEFAULT_GUI_FONT);
+	wxFont boldFont = normalFont;
+	boldFont.SetWeight(wxBOLD);
+	memDc.SetFont( boldFont );
+#endif
+
+	memDc.GetTextExtent(wxT("Tp"), &width, &height);
+	int tabHeight = height + wxFNB_HEIGHT_SPACER; // We use 10 pixels as padding
+
+	wxWindow::Create(parent, id, pos, wxSize(size.x, tabHeight), style | wxNO_BORDER | wxNO_FULL_REPAINT_ON_RESIZE);
+
+	m_pDropTarget = new wxFNBDropTarget<wxPageContainer>(this, &wxPageContainer::OnDropTarget);
+	SetDropTarget(m_pDropTarget);
+}
+
+wxPageContainer::~wxPageContainer(void)
+{
+	if(m_pRightClickMenu)
+	{
+		delete m_pRightClickMenu;
+		m_pRightClickMenu = NULL;
+	}
+}
+
+void wxPageContainer::OnPaint(wxPaintEvent & event)
+{
+	wxBufferedPaintDC dc(this);
+	wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer( GetParent()->GetWindowStyleFlag() );
+
+	render->DrawTabs(this, dc, event);
+}
+
+bool wxPageContainer::AddPage(const wxString& caption, const bool selected, const int imgindex)
+{
+	if(selected)
+	{
+		m_iPreviousActivePage = m_iActivePage;
+		m_iActivePage = (int)m_pagesInfoVec.GetCount();
+	}
+
+	/// Create page info and add it to the vector
+	wxPageInfo pageInfo(caption, imgindex);
+	m_pagesInfoVec.Add(pageInfo);
+	Refresh();
+	return true;
+}
+
+bool wxPageContainer::InsertPage(size_t index, wxWindow* /*page*/, const wxString& text, bool select, const int imgindex)
+{
+	if(select)
+	{
+		m_iPreviousActivePage = m_iActivePage;
+		m_iActivePage = (int)m_pagesInfoVec.GetCount();
+	}
+	wxPageInfo pgInfo(text, imgindex);
+//	pgInfo.SetPosition(wxPoint(1, 1));
+	m_pagesInfoVec.Insert(pgInfo, index);
+	Refresh();
+	return true;
+}
+
+void wxPageContainer::OnSize(wxSizeEvent& WXUNUSED(event))
+{
+	// When resizing the control, try to fit to screen as many tabs as we we can
+	long style = GetParent()->GetWindowStyleFlag();
+	wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer(style);
+	std::vector<wxRect> vTabInfo;
+
+	int from = 0;
+	int page = GetSelection();
+	for(; from<m_nFrom; from++)
+	{
+		vTabInfo.clear();
+		render->NumberTabsCanFit( this, vTabInfo, from );
+		if(page - from >= static_cast<int>( vTabInfo.size() ))
+			continue;
+		break;
+	}
+	m_nFrom = from;
+	Refresh(); // Call on paint
+}
+
+void wxPageContainer::OnMiddleDown(wxMouseEvent& event)
+{
+	// Test if this style is enabled
+	long style = GetParent()->GetWindowStyleFlag();
+	if(!(style & wxFNB_MOUSE_MIDDLE_CLOSES_TABS))
+		return;
+
+	wxPageInfo pgInfo;
+	int tabIdx;
+	int where = HitTest(event.GetPosition(), pgInfo, tabIdx);
+	switch(where)
+	{
+	case wxFNB_TAB:
+		{
+			DeletePage((size_t)tabIdx);
+			break;
+		}
+	default:
+		break;
+	}
+	event.Skip();
+}
+
+void wxPageContainer::OnRightDown(wxMouseEvent& event)
+{
+	wxPageInfo pgInfo;
+	int tabIdx;
+	int where = HitTest(event.GetPosition(), pgInfo, tabIdx);
+	switch(where)
+	{
+	case wxFNB_TAB:
+	case wxFNB_TAB_X:
+		{
+			if(!m_pagesInfoVec[tabIdx].GetEnabled())
+				break;
+
+			// Set the current tab to be active
+			SetSelection((size_t)tabIdx);
+
+			// If the owner has defined a context menu for the tabs,
+			// popup the right click menu
+			if (m_pRightClickMenu)
+				PopupMenu(m_pRightClickMenu);
+			else
+			{
+				// send a message to popup a custom menu
+				wxFlatNotebookEvent event(wxEVT_COMMAND_FLATNOTEBOOK_CONTEXT_MENU, GetParent()->GetId());
+				event.SetSelection((int)tabIdx);
+				event.SetOldSelection((int)m_iActivePage);
+				event.SetEventObject(GetParent());
+				GetParent()->GetEventHandler()->ProcessEvent(event);
+			}
+		}
+		break;
+	default:
+		break;
+	}
+	event.Skip();
+}
+
+void wxPageContainer::OnLeftDown(wxMouseEvent& event)
+{
+	wxPageInfo pgInfo;
+	int tabIdx;
+
+	// Reset buttons status
+	m_nXButtonStatus     = wxFNB_BTN_NONE;
+	m_nLeftButtonStatus  = wxFNB_BTN_NONE;
+	m_nRightButtonStatus = wxFNB_BTN_NONE;
+	m_nTabXButtonStatus  = wxFNB_BTN_NONE;
+	m_nArrowDownButtonStatus = wxFNB_BTN_NONE;
+
+	m_nLeftClickZone = HitTest(event.GetPosition(), pgInfo, tabIdx);
+	switch(m_nLeftClickZone)
+	{
+	case wxFNB_DROP_DOWN_ARROW:
+		m_nArrowDownButtonStatus = wxFNB_BTN_PRESSED;
+		Refresh();
+		break;
+	case wxFNB_LEFT_ARROW:
+		m_nLeftButtonStatus = wxFNB_BTN_PRESSED;
+		Refresh();
+		break;
+	case wxFNB_RIGHT_ARROW:
+		m_nRightButtonStatus = wxFNB_BTN_PRESSED;
+		Refresh();
+		break;
+	case wxFNB_X:
+		m_nXButtonStatus = wxFNB_BTN_PRESSED;
+		Refresh();
+		break;
+	case wxFNB_TAB_X:
+		m_nTabXButtonStatus = wxFNB_BTN_PRESSED;
+		Refresh();
+		break;
+	case wxFNB_TAB:
+		{
+			if(m_iActivePage != tabIdx)
+			{
+				// Incase the tab is disabled, we dont allow to choose it
+				if(!m_pagesInfoVec[tabIdx].GetEnabled())
+					break;
+
+				SetSelection(tabIdx);
+			}
+			break;
+		}
+	}
+}
+
+void wxPageContainer::OnLeftUp(wxMouseEvent& event)
+{
+	wxPageInfo pgInfo;
+	int tabIdx;
+
+	// forget the zone that was initially clicked
+	m_nLeftClickZone = wxFNB_NOWHERE;
+
+	int where = HitTest(event.GetPosition(), pgInfo, tabIdx);
+	switch(where)
+	{
+	case wxFNB_LEFT_ARROW:
+		{
+			if(m_nFrom == 0)
+				break;
+
+			// Make sure that the button was pressed before
+			if(m_nLeftButtonStatus != wxFNB_BTN_PRESSED)
+				break;
+
+			m_nLeftButtonStatus = wxFNB_BTN_HOVER;
+
+			// We scroll left with bulks of 5
+			int scrollLeft = GetNumTabsCanScrollLeft();
+
+			m_nFrom -= scrollLeft;
+			if(m_nFrom < 0)
+				m_nFrom = 0;
+
+			Refresh();
+			break;
+		}
+	case wxFNB_RIGHT_ARROW:
+		{
+			if(m_nFrom >= (int)m_pagesInfoVec.GetCount() - 1)
+				break;
+
+			// Make sure that the button was pressed before
+			if(m_nRightButtonStatus != wxFNB_BTN_PRESSED)
+				break;
+
+			m_nRightButtonStatus = wxFNB_BTN_HOVER;
+
+			// Check if the right most tab is visible, if it is
+			// don't rotate right anymore
+			if(m_pagesInfoVec[m_pagesInfoVec.GetCount()-1].GetPosition() != wxPoint(-1, -1))
+				break;
+
+			int lastVisibleTab = GetLastVisibleTab();
+			if(lastVisibleTab < 0)
+			{
+				// Probably the screen is too small for displaying even a single
+				// tab, in this case we do nothing
+				break;
+			}
+
+			m_nFrom += GetNumOfVisibleTabs();
+			Refresh();
+			break;
+		}
+	case wxFNB_X:
+		{
+			// Make sure that the button was pressed before
+			if(m_nXButtonStatus != wxFNB_BTN_PRESSED)
+				break;
+
+			m_nXButtonStatus = wxFNB_BTN_HOVER;
+
+			DeletePage((size_t)m_iActivePage);
+			break;
+		}
+	case wxFNB_TAB_X:
+		{
+			// Make sure that the button was pressed before
+			if(m_nTabXButtonStatus != wxFNB_BTN_PRESSED)
+				break;
+
+			m_nTabXButtonStatus = wxFNB_BTN_HOVER;
+
+			DeletePage((size_t)m_iActivePage);
+			break;
+		}
+	case wxFNB_DROP_DOWN_ARROW:
+		{
+			// Make sure that the button was pressed before
+			if(m_nArrowDownButtonStatus != wxFNB_BTN_PRESSED)
+				break;
+
+			m_nArrowDownButtonStatus = wxFNB_BTN_NONE;
+
+			// Refresh the button status
+			wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer( GetParent()->GetWindowStyleFlag() );
+			wxClientDC dc(this);
+			render->DrawDropDownArrow(this, dc);
+
+			PopupTabsMenu();
+			break;
+		}
+	}
+}
+
+int wxPageContainer::HitTest(const wxPoint& pt, wxPageInfo& pageInfo, int &tabIdx)
+{
+	wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer( GetParent()->GetWindowStyleFlag() );
+
+	wxRect rect = GetClientRect();
+	int btnLeftPos = render->GetLeftButtonPos(this);
+	int btnRightPos = render->GetRightButtonPos(this);
+	int btnXPos =render->GetXPos(this);
+	long style = GetParent()->GetWindowStyleFlag();
+
+	tabIdx = -1;
+	if(m_pagesInfoVec.IsEmpty())
+	{
+		return wxFNB_NOWHERE;
+	}
+
+	rect = wxRect(btnXPos, 8, 16, 16);
+	if(RectContains(rect,pt))
+	{
+		return (style & wxFNB_NO_X_BUTTON) ? wxFNB_NOWHERE : wxFNB_X;
+	}
+
+	rect = wxRect(btnRightPos, 8, 16, 16);
+	if( style & wxFNB_DROPDOWN_TABS_LIST )
+	{
+		rect = wxRect(render->GetDropArrowButtonPos( this ), 8, 16, 16);
+		if( RectContains(rect,pt) )
+			return wxFNB_DROP_DOWN_ARROW;
+	}
+
+	if(RectContains(rect,pt))
+	{
+		return (style & wxFNB_NO_NAV_BUTTONS) ? wxFNB_NOWHERE : wxFNB_RIGHT_ARROW;
+	}
+
+
+	rect = wxRect(btnLeftPos, 8, 16, 16);
+	if(RectContains(rect,pt))
+	{
+		return (style & wxFNB_NO_NAV_BUTTONS) ? wxFNB_NOWHERE : wxFNB_LEFT_ARROW;
+	}
+
+	// Test whether a left click was made on a tab
+	bool bFoundMatch = false;
+	for(size_t cur=m_nFrom; cur<m_pagesInfoVec.GetCount(); cur++)
+	{
+		wxPageInfo pgInfo = m_pagesInfoVec[cur];
+		if(pgInfo.GetPosition() == wxPoint(-1, -1))
+			continue;
+
+		// check for mouse over tab's x button
+		if(style & wxFNB_X_ON_TAB && (int)cur == GetSelection())
+		{
+			// 'x' button exists on a tab
+			if(RectContains(m_pagesInfoVec[cur].GetXRect(),pt))
+			{
+				pageInfo = pgInfo;
+				tabIdx = (int)cur;
+				return wxFNB_TAB_X;
+			}
+		}
+
+		if(style & wxFNB_VC8)
+		{
+			if(m_pagesInfoVec[cur].GetRegion().Contains(pt) == wxInRegion)
+			{
+				if(bFoundMatch || (int)cur == GetSelection())
+				{
+					pageInfo = pgInfo;
+					tabIdx = (int)cur;
+					return wxFNB_TAB;
+				}
+				pageInfo = pgInfo;
+				tabIdx = (int)cur;
+				bFoundMatch = true;
+			}
+		}
+		else
+		{
+
+			wxRect tabRect = wxRect(pgInfo.GetPosition().x, pgInfo.GetPosition().y,
+				pgInfo.GetSize().x, pgInfo.GetSize().y);
+			if(RectContains(tabRect,pt))
+			{
+				// We have a match
+				pageInfo = pgInfo;
+				tabIdx = (int)cur;
+				return wxFNB_TAB;
+			}
+		}
+	}
+
+	if(bFoundMatch)
+		return wxFNB_TAB;
+
+	// Default
+	return wxFNB_NOWHERE;
+}
+
+void wxPageContainer::SetSelection(size_t page)
+{
+	wxFlatNotebook* book = (wxFlatNotebook*)GetParent();
+	book->SetSelection(page);
+	DoSetSelection(page);
+}
+
+void wxPageContainer::DoSetSelection(size_t page)
+{
+	// Make sure that the selection is visible
+	if(page < m_pagesInfoVec.GetCount())
+	{
+		//! fix for tabfocus
+		wxWindow* da_page = ((wxFlatNotebook *)m_pParent)->GetPage(page);
+		if ( da_page!=NULL )
+			da_page->SetFocus();
+	}
+
+	if( !IsTabVisible(page) )
+	{
+		FNB_LOG_MSG( wxT("Tab ") << (int)page << wxT(" is not visible"));
+		FNB_LOG_MSG( wxT("m_nFrom=") << m_nFrom << wxT(", Selection=") << (int)page );
+
+		// Try to remove one tab from start and try again
+		if( !CanFitToScreen(page) )
+		{
+			if( m_nFrom > (int)page )
+				m_nFrom = (int)page;
+			else
+			{
+				while( m_nFrom < (int)page )
+				{
+					m_nFrom++;
+					if( CanFitToScreen(page) )
+						break;
+				}
+			}
+			FNB_LOG_MSG( wxT("Adjusting m_nFrom to=") << m_nFrom);
+		}
+	}
+	else
+	{
+		FNB_LOG_MSG( wxT("Tab ") << (int)page << wxT(" is visible"));
+	}
+	Refresh();
+}
+
+void wxPageContainer::DeletePage(size_t page)
+{
+	wxFlatNotebook* book = (wxFlatNotebook*)GetParent();
+	book->DeletePage(page);
+	book->Refresh();
+}
+
+bool wxPageContainer::IsTabVisible(size_t page)
+{
+	int iPage = (int)page;
+	int iLastVisiblePage = GetLastVisibleTab();
+
+	return iPage <= iLastVisiblePage && iPage >= m_nFrom;
+}
+
+void wxPageContainer::DoDeletePage(size_t page)
+{
+	// Remove the page from the vector
+	wxFlatNotebook* book = (wxFlatNotebook*)GetParent();
+	m_pagesInfoVec.RemoveAt(page);
+
+	// Thanks to Yiannis AKA Mandrav
+	if (m_iActivePage >= (int)page)
+	{
+		m_iActivePage--;
+		m_iPreviousActivePage = -1;
+	}
+
+	// The delete page was the last first on the array,
+	// but the book still has more pages, so we set the
+	// active page to be the first one (0)
+	if(m_iActivePage < 0 && !m_pagesInfoVec.empty())
+	{
+		m_iPreviousActivePage = -1;
+		m_iActivePage = 0;
+	}
+
+	// Refresh the tabs
+	if(m_iActivePage >= 0)
+	{
+		book->m_bForceSelection = true;
+		book->SetSelection(m_iActivePage);
+		book->m_bForceSelection = false;
+	}
+
+	if(m_pagesInfoVec.empty())
+	{
+		// Erase the page container drawings
+		wxClientDC dc(this);
+		dc.Clear();
+	}
+}
+
+void wxPageContainer::DeleteAllPages()
+{
+	m_iActivePage = -1;
+	m_iPreviousActivePage = -1;
+	m_nFrom = 0;
+	m_pagesInfoVec.Clear();
+
+	// Erase the page container drawings
+	wxClientDC dc(this);
+	dc.Clear();
+}
+
+void wxPageContainer::OnMouseMove(wxMouseEvent& event)
+{
+	if (!m_pagesInfoVec.empty() && IsShown())
+	{
+		const int xButtonStatus = m_nXButtonStatus;
+		const int xTabButtonStatus = m_nTabXButtonStatus;
+		const int rightButtonStatus = m_nRightButtonStatus;
+		const int leftButtonStatus = m_nLeftButtonStatus;
+		const int dropDownButtonStatus = m_nArrowDownButtonStatus;
+
+		long style = GetParent()->GetWindowStyleFlag();
+
+		m_nXButtonStatus = wxFNB_BTN_NONE;
+		m_nRightButtonStatus = wxFNB_BTN_NONE;
+		m_nLeftButtonStatus = wxFNB_BTN_NONE;
+		m_nTabXButtonStatus = wxFNB_BTN_NONE;
+		m_nArrowDownButtonStatus = wxFNB_BTN_NONE;
+
+		wxPageInfo pgInfo;
+		int tabIdx;
+
+		int where = HitTest(event.GetPosition(), pgInfo, tabIdx);
+		switch ( where )
+		{
+		case wxFNB_X:
+			if (event.LeftIsDown())
+			{
+				m_nXButtonStatus = (m_nLeftClickZone==wxFNB_X) ? wxFNB_BTN_PRESSED : wxFNB_BTN_NONE;
+			}
+			else
+			{
+				m_nXButtonStatus = wxFNB_BTN_HOVER;
+			}
+			break;
+		case wxFNB_DROP_DOWN_ARROW:
+			if (event.LeftIsDown())
+			{
+				m_nArrowDownButtonStatus = (m_nLeftClickZone == wxFNB_DROP_DOWN_ARROW) ? wxFNB_BTN_PRESSED : wxFNB_BTN_NONE;
+			}
+			else
+			{
+				m_nArrowDownButtonStatus = wxFNB_BTN_HOVER;
+			}
+			break;
+		case wxFNB_TAB_X:
+			if (event.LeftIsDown())
+			{
+				m_nTabXButtonStatus = (m_nLeftClickZone==wxFNB_TAB_X) ? wxFNB_BTN_PRESSED : wxFNB_BTN_NONE;
+			}
+			else
+			{
+				m_nTabXButtonStatus = wxFNB_BTN_HOVER;
+			}
+			break;
+		case wxFNB_RIGHT_ARROW:
+			if (event.LeftIsDown())
+			{
+				m_nRightButtonStatus = (m_nLeftClickZone==wxFNB_RIGHT_ARROW) ? wxFNB_BTN_PRESSED : wxFNB_BTN_NONE;
+			}
+			else
+			{
+				m_nRightButtonStatus = wxFNB_BTN_HOVER;
+			}
+			break;
+
+		case wxFNB_LEFT_ARROW:
+			if (event.LeftIsDown())
+			{
+				m_nLeftButtonStatus = (m_nLeftClickZone==wxFNB_LEFT_ARROW) ? wxFNB_BTN_PRESSED : wxFNB_BTN_NONE;
+			}
+			else
+			{
+				m_nLeftButtonStatus = wxFNB_BTN_HOVER;
+			}
+			break;
+
+		case wxFNB_TAB:
+			// Call virtual method for showing tooltip
+			ShowTabTooltip(tabIdx);
+			if(!GetEnabled((size_t)tabIdx))
+			{
+				// Set the cursor to be 'No-entry'
+				::wxSetCursor(wxCURSOR_NO_ENTRY);
+			}
+
+			// Support for drag and drop
+			if(event.Dragging() && !(style & wxFNB_NODRAG))
+			{
+				wxFNBDragInfo draginfo(this, tabIdx);
+				wxFNBDragInfoDataObject dataobject(wxDataFormat(wxT("wxFNB")));
+				dataobject.SetData(sizeof(wxFNBDragInfo), &draginfo);
+				wxFNBDropSource dragSource(this);
+				dragSource.SetData(dataobject);
+				dragSource.DoDragDrop(wxDrag_DefaultMove);
+			}
+			break;
+		default:
+			m_nTabXButtonStatus = wxFNB_BTN_NONE;
+			break;
+		}
+
+		const bool bRedrawX = m_nXButtonStatus != xButtonStatus;
+		const bool bRedrawDropArrow = m_nArrowDownButtonStatus != dropDownButtonStatus;
+		const bool bRedrawRight = m_nRightButtonStatus != rightButtonStatus;
+		const bool bRedrawLeft = m_nLeftButtonStatus != leftButtonStatus;
+		const bool bRedrawTabX = m_nTabXButtonStatus != xTabButtonStatus;
+
+		wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer( GetParent()->GetWindowStyleFlag() );
+
+		if (bRedrawX || bRedrawRight || bRedrawLeft || bRedrawTabX || bRedrawDropArrow)
+		{
+			wxClientDC dc(this);
+			if (bRedrawX)
+			{
+				render->DrawX(this, dc);
+			}
+			if (bRedrawLeft)
+			{
+				render->DrawLeftArrow(this, dc);
+			}
+			if (bRedrawRight)
+			{
+				render->DrawRightArrow(this, dc);
+			}
+			if (bRedrawTabX)
+			{
+				FNB_LOG_MSG( wxT("Refreshing Tab 'X' button with status=") << m_nTabXButtonStatus << wxT(" and tabIdx=") << tabIdx );
+				render->DrawTabX(this, dc, pgInfo.GetXRect(), tabIdx, m_nTabXButtonStatus);
+			}
+			if (bRedrawDropArrow)
+			{
+				render->DrawDropDownArrow(this, dc);
+			}
+		}
+	}
+	event.Skip();
+}
+
+int wxPageContainer::GetLastVisibleTab()
+{
+	int i;
+	if( m_nFrom < 0)
+		return -1;
+
+	for(i=m_nFrom; i<(int)m_pagesInfoVec.GetCount(); i++)
+	{
+		if(m_pagesInfoVec[i].GetPosition() == wxPoint(-1, -1))
+			break;
+	}
+	return (i-1);
+}
+
+int wxPageContainer::GetNumTabsCanScrollLeft()
+{
+	int i;
+
+	// Reserved area for the buttons (<>x)
+	wxRect rect = GetClientRect();
+	int clientWidth = rect.width;
+	int posx = ((wxFlatNotebook *)m_pParent)->m_nPadding, numTabs = 0, tabHeight, tabWidth;
+
+	wxClientDC dc(this);
+
+	// Incase we have error prevent crash
+	if(m_nFrom < 0)
+		return 0;
+
+	long style = GetParent()->GetWindowStyleFlag();
+	wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer(style);
+
+	tabHeight = render->CalcTabHeight(this);
+	for(i=m_nFrom; i>=0; i--)
+	{
+		tabWidth = render->CalcTabWidth(this, i, tabHeight);
+		if(posx + tabWidth + render->GetButtonsAreaLength(this) >= clientWidth)
+			break;
+
+		numTabs++;
+		posx += tabWidth;
+	}
+	return numTabs;
+}
+
+bool wxPageContainer::IsDefaultTabs()
+{
+	long style = GetParent()->GetWindowStyleFlag();
+	bool res = (style & wxFNB_VC71) || (style & wxFNB_FANCY_TABS) || (style & wxFNB_VC8);
+	return !res;
+}
+
+void wxPageContainer::AdvanceSelection(bool bForward)
+{
+	int nSel = GetSelection();
+
+	if(nSel < 0)
+		return;
+
+	int nMax = (int)GetPageCount() - 1;
+	if ( bForward )
+		SetSelection(nSel == nMax ? 0 : nSel + 1);
+	else
+		SetSelection(nSel == 0 ? nMax : nSel - 1);
+}
+
+
+void wxPageContainer::OnMouseLeave(wxMouseEvent& event)
+{
+	m_nLeftButtonStatus = wxFNB_BTN_NONE;
+	m_nXButtonStatus = wxFNB_BTN_NONE;
+	m_nRightButtonStatus = wxFNB_BTN_NONE;
+	m_nTabXButtonStatus = wxFNB_BTN_NONE;
+	m_nArrowDownButtonStatus = wxFNB_BTN_NONE;
+
+	long style = GetParent()->GetWindowStyleFlag();
+	wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer(style);
+
+	wxClientDC dc(this);
+	render->DrawX(this, dc);
+	render->DrawLeftArrow(this, dc);
+	render->DrawRightArrow(this, dc);
+	if(GetSelection() != -1 && IsTabVisible((size_t)GetSelection()))
+	{
+		render->DrawTabX(this, dc, m_pagesInfoVec[GetSelection()].GetXRect(), GetSelection(), m_nTabXButtonStatus);
+	}
+
+	event.Skip();
+}
+
+void wxPageContainer::OnMouseEnterWindow(wxMouseEvent& event)
+{
+	m_nLeftButtonStatus = wxFNB_BTN_NONE;
+	m_nXButtonStatus = wxFNB_BTN_NONE;
+	m_nRightButtonStatus = wxFNB_BTN_NONE;
+	m_nLeftClickZone = wxFNB_BTN_NONE;
+	m_nArrowDownButtonStatus = wxFNB_BTN_NONE;
+
+	event.Skip();
+}
+
+void wxPageContainer::ShowTabTooltip(int tabIdx)
+{
+	wxWindow *pWindow = ((wxFlatNotebook *)m_pParent)->GetPage(tabIdx);
+	if( pWindow )
+	{
+		wxToolTip *pToolTip = pWindow->GetToolTip();
+		if(pToolTip && pToolTip->GetWindow() == pWindow)
+			SetToolTip(pToolTip->GetTip());
+	}
+}
+
+void wxPageContainer::SetPageImageIndex(size_t page, int imgindex)
+{
+	if(page < m_pagesInfoVec.GetCount())
+	{
+		m_pagesInfoVec[page].SetImageIndex(imgindex);
+		Refresh();
+	}
+}
+
+int wxPageContainer::GetPageImageIndex(size_t page)
+{
+	if(page < m_pagesInfoVec.GetCount())
+	{
+		return m_pagesInfoVec[page].GetImageIndex();
+	}
+	return -1;
+}
+
+wxDragResult wxPageContainer::OnDropTarget(wxCoord x, wxCoord y, int nTabPage, wxWindow * wnd_oldContainer)
+{
+	// Disable drag'n'drop for disabled tab
+	if(!((wxPageContainer *)wnd_oldContainer)->m_pagesInfoVec[nTabPage].GetEnabled())
+		return wxDragCancel;
+
+	wxLogTrace(wxTraceMask(), _("Old Page Index = %i"), nTabPage);
+	wxPageContainer * oldContainer = (wxPageContainer *)wnd_oldContainer;
+	int nIndex = -1;
+	wxPageInfo pgInfo;
+	int where = HitTest(wxPoint(x, y), pgInfo, nIndex);
+	wxLogTrace(wxTraceMask(), _("OnDropTarget: index by HitTest = %i"), nIndex);
+	wxFlatNotebook * oldNotebook = (wxFlatNotebook *)oldContainer->GetParent();
+	wxFlatNotebook * newNotebook = (wxFlatNotebook *)GetParent();
+
+	if(oldNotebook == newNotebook)
+	{
+		if(nTabPage >= 0)
+		{
+			switch(where)
+			{
+			case wxFNB_TAB:
+				MoveTabPage(nTabPage, nIndex);
+				break;
+			case wxFNB_NOWHERE:
+				{
+				}
+				break;
+			default:
+				break;
+			}
+		}
+	}
+	else if ( GetParent()->GetWindowStyleFlag() & wxFNB_ALLOW_FOREIGN_DND )
+	{
+#if defined(__WXMSW__) || defined(__WXGTK__)
+		if(nTabPage >= 0)
+		{
+			wxWindow * window = oldNotebook->GetPage(nTabPage);
+			if(window)
+			{
+				wxString caption = oldContainer->GetPageText(nTabPage);
+
+				// Pass the image to the new container
+				// incase that the new container (this) does not have image list we dont pass the image
+				// to the new notebook
+				int newIndx( wxNOT_FOUND );
+
+				if( m_ImageList )
+				{
+					int imageindex = oldContainer->GetPageImageIndex(nTabPage);
+					if( imageindex >= 0 )
+					{
+						wxBitmap bmp( (*oldContainer->GetImageList())[imageindex] );
+						m_ImageList->Add( bmp );
+						newIndx = static_cast<int>(m_ImageList->GetCount() - 1);
+					}
+				}
+
+				oldNotebook->RemovePage( nTabPage );
+				window->Reparent( newNotebook );
+				newNotebook->InsertPage(nIndex, window, caption, true, newIndx);
+			}
+		}
+#endif
+	}
+	return wxDragMove;
+}
+
+void wxPageContainer::MoveTabPage(int nMove, int nMoveTo)
+{
+	if(nMove == nMoveTo)
+		return;
+
+	else if(nMoveTo < (int)((wxFlatNotebook *)m_pParent)->m_windows.GetCount())
+		nMoveTo++;
+
+	m_pParent->Freeze();
+	// Remove the window from the main sizer
+	int nCurSel = ((wxFlatNotebook *)m_pParent)->m_pages->GetSelection();
+	((wxFlatNotebook *)m_pParent)->m_mainSizer->Detach(((wxFlatNotebook *)m_pParent)->m_windows[nCurSel]);
+	((wxFlatNotebook *)m_pParent)->m_windows[nCurSel]->Hide();
+
+	wxWindow *pWindow = ((wxFlatNotebook *)m_pParent)->m_windows[nMove];
+	((wxFlatNotebook *)m_pParent)->m_windows.RemoveAt(nMove);
+	((wxFlatNotebook *)m_pParent)->m_windows.Insert(pWindow, nMoveTo-1);
+
+	wxPageInfo pgInfo = m_pagesInfoVec[nMove];
+
+	m_pagesInfoVec.RemoveAt( nMove );
+	m_pagesInfoVec.Insert(pgInfo, nMoveTo - 1);
+
+	// Add the page according to the style
+	wxBoxSizer* pSizer = ((wxFlatNotebook *)m_pParent)->m_mainSizer;
+	long style = GetParent()->GetWindowStyleFlag();
+
+
+	if(style & wxFNB_BOTTOM)
+	{
+		pSizer->Insert(0, pWindow, 1, wxEXPAND);
+	}
+	else
+	{
+		// We leave a space of 1 pixel around the window
+		pSizer->Add(pWindow, 1, wxEXPAND);
+	}
+	pWindow->Show();
+
+	pSizer->Layout();
+	m_iActivePage = nMoveTo-1;
+	m_iPreviousActivePage = -1;
+	DoSetSelection(m_iActivePage);
+	Refresh();
+	m_pParent->Thaw();
+}
+
+bool wxPageContainer::CanFitToScreen(size_t page)
+{
+	// Incase the from is greater than page,
+	// we need to reset the m_nFrom, so in order
+	// to force the caller to do so, we return false
+	if(m_nFrom > (int)page)
+		return false;
+
+	long style = GetParent()->GetWindowStyleFlag();
+	wxFNBRendererPtr render = wxFNBRendererMgrST::Get()->GetRenderer(style);
+	std::vector<wxRect> vTabInfo;
+	render->NumberTabsCanFit( this, vTabInfo );
+
+	if(static_cast<int>(page) - m_nFrom >= static_cast<int>( vTabInfo.size() ))
+		return false;
+	return true;
+}
+
+int wxPageContainer::GetNumOfVisibleTabs()
+{
+	int i=m_nFrom;
+	int counter = 0;
+	for(; i<(int)m_pagesInfoVec.GetCount(); i++, ++counter)
+	{
+		if(m_pagesInfoVec[i].GetPosition() == wxPoint(-1, -1))
+			break;
+	}
+	return counter;
+}
+
+bool wxPageContainer::GetEnabled(size_t page)
+{
+	if(page >= m_pagesInfoVec.GetCount())
+		return true;	// Seems strange, but this is the default
+	return m_pagesInfoVec[page].GetEnabled();
+}
+
+void wxPageContainer::Enable(size_t page, bool enabled)
+{
+	if(page >= m_pagesInfoVec.GetCount())
+		return ;
+    m_pagesInfoVec[page].Enable(enabled);
+    return;
+}
+
+wxColor wxPageContainer::GetSingleLineBorderColor()
+{
+	if(HasFlag(wxFNB_FANCY_TABS))
+		return m_colorFrom;
+	return *wxWHITE;
+}
+
+bool wxPageContainer::HasFlag(int flag)
+{
+	long style = GetParent()->GetWindowStyleFlag();
+	bool res = style & flag ? true : false;
+	return res;
+}
+
+void wxPageContainer::ClearFlag(int flag)
+{
+	long style = GetParent()->GetWindowStyleFlag();
+	style &= ~( flag );
+	wxWindowBase::SetWindowStyleFlag(style);
+}
+
+bool wxPageContainer::TabHasImage(int tabIdx)
+{
+	if(m_ImageList)
+		return m_pagesInfoVec[tabIdx].GetImageIndex() != -1;
+	return false;
+}
+
+void wxPageContainer::OnLeftDClick(wxMouseEvent& event)
+{
+	wxPageInfo pgInfo;
+	int tabIdx;
+	int where = HitTest(event.GetPosition(), pgInfo, tabIdx);
+	switch(where)
+	{
+	case wxFNB_TAB:
+		if(HasFlag(wxFNB_DCLICK_CLOSES_TABS))
+		{
+			{
+				DeletePage((size_t)tabIdx);
+				break;
+			}
+		}
+	case wxFNB_X:
+		{
+			OnLeftDown(event);
+			break;
+		}
+	default:
+		event.Skip();
+		break;
+	}
+}
+
+void wxPageContainer::PopupTabsMenu()
+{
+	wxMenu popupMenu;
+
+	for(size_t i=0; i<m_pagesInfoVec.GetCount(); i++)
+	{
+		wxPageInfo pi = m_pagesInfoVec[i];
+		wxMenuItem *item = new wxMenuItem(&popupMenu, static_cast<int>(i), pi.GetCaption(), pi.GetCaption(), wxITEM_NORMAL);
+
+		// This code is commented, since there is an alignment problem with wx2.6.3 & Menus
+//		if( TabHasImage(static_cast<int>(i)) )
+//			item->SetBitmaps( (*m_ImageList)[pi.GetImageIndex()] );
+
+		popupMenu.Append( item );
+	}
+
+	// connect an event handler to our menu
+	popupMenu.Connect(wxID_ANY, wxEVT_COMMAND_MENU_SELECTED, wxCommandEventHandler(wxPageContainer::OnTabMenuSelection), NULL, this);
+	PopupMenu( &popupMenu );
+}
+
+void wxPageContainer::OnTabMenuSelection(wxCommandEvent &event)
+{
+	int selection = event.GetId();
+	static_cast<wxFlatNotebook*>(m_pParent)->SetSelection( (size_t)selection );
+}
+
+// Draw small arrow at the place that the tab will be placed
+void wxPageContainer::DrawDragHint()
+{
+	// get the index of tab that will be replaced with the dragged tab
+	wxPageInfo info;
+	int tabIdx;
+	wxPoint pt = ::wxGetMousePosition();
+    wxPoint client_pt = ScreenToClient(pt);
+	HitTest(client_pt, info, tabIdx);
+	wxFNBRendererMgrST::Get()->GetRenderer( GetParent()->GetWindowStyleFlag() )->DrawDragHint(this, tabIdx);
+}
Index: src/sdk/editormanager.cpp
===================================================================
--- src/sdk/editormanager.cpp	(revision 4255)
+++ src/sdk/editormanager.cpp	(working copy)
@@ -65,6 +65,7 @@
 #include "searchresultslog.h"
 #include "projectfileoptionsdlg.h"
 
+#include "tearawaynotebook.h"
 #include "wx/wxFlatNotebook/wxFlatNotebook.h"
 
 
@@ -111,6 +112,7 @@
 static const int idNBTabSplitVert = wxNewId();
 static const int idNBTabUnsplit = wxNewId();
 static const int idNBTabClose = wxNewId();
+static const int idNBTabDetach = wxNewId();
 static const int idNBTabCloseAll = wxNewId();
 static const int idNBTabCloseAllOthers = wxNewId();
 static const int idNBTabSave = wxNewId();
@@ -191,6 +193,7 @@
     EVT_MENU(idNBTabTop, EditorManager::OnTabPosition)
     EVT_MENU(idNBTabBottom, EditorManager::OnTabPosition)
     EVT_MENU(idNBTabClose, EditorManager::OnClose)
+    EVT_MENU(idNBTabDetach, EditorManager::OnDetach)
     EVT_MENU(idNBTabCloseAll, EditorManager::OnCloseAll)
     EVT_MENU(idNBTabCloseAllOthers, EditorManager::OnCloseAllOthers)
     EVT_MENU(idNBTabSave, EditorManager::OnSave)
@@ -219,9 +222,13 @@
 {
     m_pData = new EditorManagerInternalData(this);
 
-    m_pNotebook = new wxFlatNotebook(Manager::Get()->GetAppWindow(), ID_NBEditorManager, wxDefaultPosition, wxDefaultSize, wxNO_FULL_REPAINT_ON_RESIZE | wxCLIP_CHILDREN);
+    m_pNotebook = new TearawayNotebook(Manager::Get()->GetAppWindow(), ID_NBEditorManager, wxDefaultPosition, wxDefaultSize, wxNO_FULL_REPAINT_ON_RESIZE | wxCLIP_CHILDREN);
     m_pNotebook->SetWindowStyleFlag(Manager::Get()->GetConfigManager(_T("app"))->ReadInt(_T("/environment/editor_tabs_style"), wxFNB_DEFAULT_STYLE | wxFNB_MOUSE_MIDDLE_CLOSES_TABS));
+    m_NotebookImages=new wxFlatNotebookImageList;
+    m_NotebookImages->Add(cbLoadBitmap(ConfigManager::GetDataFolder() + _T("/images/file-missing.png")));
+    m_pNotebook->SetImageList(m_NotebookImages);
 
+
 #ifdef USE_OPENFILES_TREE
     m_pData->m_TreeNeedsRefresh = false;
     ShowOpenFilesTree(Manager::Get()->GetConfigManager(_T("editor"))->ReadBool(_T("/show_opened_files_tree"), true));
@@ -254,6 +261,7 @@
     delete m_Theme;
     delete m_LastFindReplaceData;
     delete m_pData->m_pImages;
+    delete m_NotebookImages;
     delete m_pData;
     Manager::Get()->GetConfigManager(_T("editor"))->Write(_T("/zoom"), m_zoom);
 } // end of destructor
@@ -2494,6 +2502,10 @@
     if (event.GetSelection() == -1)
         return;
     wxMenu* pop = new wxMenu;
+    if(m_pNotebook->IsDetached(m_pNotebook->GetSelection()))
+        pop->Append(idNBTabDetach, _("Reattach"));
+    else
+        pop->Append(idNBTabDetach, _("Detach"));
     pop->Append(idNBTabClose, _("Close"));
     if (GetEditorsCount() > 1)
     {
@@ -2547,6 +2559,23 @@
     delete pop;
 }
 
+void EditorManager::OnDetach(wxCommandEvent& event)
+{
+    size_t page=m_pNotebook->GetSelection();
+    if(m_pNotebook->IsDetached(page))
+    {
+        if(m_pNotebook->UndetachPage(page))
+            m_pNotebook->SetPageImageIndex(page,-1);
+    }
+    else
+    {
+        if(m_pNotebook->DetachPage(page,_T(""))) //TODO: figure out sensible window name (full path to file)
+            m_pNotebook->SetPageImageIndex(page,0);
+    }
+
+}
+
+
 void EditorManager::OnClose(wxCommandEvent& event)
 {
     Manager::Get()->GetEditorManager()->Close(GetActiveEditor());
Index: src/plugins/contrib/codesnippets/codesnippets.cpp
===================================================================
--- src/plugins/contrib/codesnippets/codesnippets.cpp	(revision 4255)
+++ src/plugins/contrib/codesnippets/codesnippets.cpp	(working copy)
@@ -1,55 +1,56 @@
-/*
-	This file is part of Code Snippets, a plugin for Code::Blocks
-	Copyright (C) 2006 Arto Jonsson
+/*
+	This file is part of Code Snippets, a plugin for Code::Blocks
+	Copyright (C) 2006 Arto Jonsson
 	Copyright (C) 2007 Pecan Heber
-
-	This program is free software; you can redistribute it and/or
-	modify it under the terms of the GNU General Public License
-	as published by the Free Software Foundation; either version 2
-	of the License, or (at your option) any later version.
-
-	This program is distributed in the hope that it will be useful,
-	but WITHOUT ANY WARRANTY; without even the implied warranty of
-	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-	GNU General Public License for more details.
-
-	You should have received a copy of the GNU General Public License
-	along with this program; if not, write to the Free Software
-	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
-*/
-// RCS-ID: $Id: codesnippets.cpp 93 2007-06-30 21:22:19Z Pecan $
 
-#if defined(CB_PRECOMP)
-#include "sdk.h"
-#else
-    #include "sdk_common.h"
-	#include <wx/event.h>
-	#include <wx/frame.h> // Manager::Get()->GetAppWindow()
-	#include <wx/intl.h>
-	#include <wx/menu.h>
-	#include <wx/menuitem.h>
-	#include <wx/string.h>
-	#include "sdk_events.h"
-	#include "manager.h"
-	#include "projectmanager.h"
+	This program is free software; you can redistribute it and/or
+	modify it under the terms of the GNU General Public License
+	as published by the Free Software Foundation; either version 2
+	of the License, or (at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU General Public License for more details.
+
+	You should have received a copy of the GNU General Public License
+	along with this program; if not, write to the Free Software
+	Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+*/
+// RCS-ID: $Id: codesnippets.cpp 93 2007-06-30 21:22:19Z Pecan $
+
+#if defined(CB_PRECOMP)
+#include "sdk.h"
+#else
+    #include "sdk_common.h"
+	#include <wx/event.h>
+	#include <wx/frame.h> // Manager::Get()->GetAppWindow()
+	#include <wx/intl.h>
+	#include <wx/menu.h>
+	#include <wx/menuitem.h>
+	#include <wx/string.h>
+	#include "sdk_events.h"
+	#include "manager.h"
+	#include "projectmanager.h"
 	#include "editormanager.h"
-	#include "personalitymanager.h"
-	#include "cbworkspace.h"
-	#include "cbproject.h"
-	#include "messagemanager.h"
-#endif
-	#include <wx/stdpaths.h>
-	#include <wx/process.h>
-
-#include <wx/dnd.h>
-
+	#include "personalitymanager.h"
+	#include "cbworkspace.h"
+	#include "cbproject.h"
+	#include "messagemanager.h"
+#endif
+	#include <wx/stdpaths.h>
+	#include <wx/process.h>
+
+#include <wx/dnd.h>
+
 #include "version.h"
-#include "codesnippets.h"
+#include "codesnippets.h"
 #include "codesnippetswindow.h"
 #include "snippetsconfig.h"
 #include "messagebox.h"
 #include <wx/wxFlatNotebook/wxFlatNotebook.h>
-#include "memorymappedfile.h"
+#include <tearawaynotebook.h>
+#include "memorymappedfile.h"
 
 #if defined(__WXGTK__)
     #include "wx/gtk/win_gtk.h"
@@ -60,50 +61,50 @@
 #if !defined(BUILDING_PLUGIN)
     #error preprocessor BUILDING_PLUGIN flag required for this target
 #endif
-
-// Register the plugin
-namespace
-{
-    PluginRegistrant<CodeSnippets> reg(_T("CodeSnippets"));
-};
-
-int idViewSnippets = wxNewId();
-
-// Events handling
-BEGIN_EVENT_TABLE(CodeSnippets, cbPlugin)
-	EVT_UPDATE_UI(idViewSnippets, CodeSnippets::OnUpdateUI)
+
+// Register the plugin
+namespace
+{
+    PluginRegistrant<CodeSnippets> reg(_T("CodeSnippets"));
+};
+
+int idViewSnippets = wxNewId();
+
+// Events handling
+BEGIN_EVENT_TABLE(CodeSnippets, cbPlugin)
+	EVT_UPDATE_UI(idViewSnippets, CodeSnippets::OnUpdateUI)
 	EVT_MENU(idViewSnippets, CodeSnippets::OnViewSnippets)
     EVT_ACTIVATE(            CodeSnippets::OnActivate)
     EVT_IDLE(                CodeSnippets::OnIdle)
     EVT_APP_START_SHUTDOWN(  CodeSnippets::OnRelease)
-END_EVENT_TABLE()
-
+END_EVENT_TABLE()
+
 // ----------------------------------------------------------------------------
-CodeSnippets::CodeSnippets()
+CodeSnippets::CodeSnippets()
 // ----------------------------------------------------------------------------
 {
-}
-
+}
+
 // ----------------------------------------------------------------------------
-CodeSnippets::~CodeSnippets()
+CodeSnippets::~CodeSnippets()
 // ----------------------------------------------------------------------------
-{
-}
-
+{
+}
+
 // ----------------------------------------------------------------------------
-void CodeSnippets::OnAttach()
+void CodeSnippets::OnAttach()
 // ----------------------------------------------------------------------------
 {
     // Initialize one and only Global class
-    // Must be done first to allocate config file
-    g_pConfig = new CodeSnippetsConfig;
+    // Must be done first to allocate config file
+    g_pConfig = new CodeSnippetsConfig;
     g_pConfig->m_bIsPlugin = true;
 
     // initialize version and logging
     m_pAppWin = Manager::Get()->GetAppWindow();
-    GetConfig()->AppName = wxT("codesnippets");
-    GetConfig()->pMainFrame  = Manager::Get()->GetAppWindow() ;
-    GetConfig()->m_pMenuBar = Manager::Get()->GetAppWindow()->GetMenuBar();
+    GetConfig()->AppName = wxT("codesnippets");
+    GetConfig()->pMainFrame  = Manager::Get()->GetAppWindow() ;
+    GetConfig()->m_pMenuBar = Manager::Get()->GetAppWindow()->GetMenuBar();
 
     AppVersion pgmVersion;
 
@@ -173,29 +174,29 @@
     m_pEdMan->GetTree()->SetDropTarget(new DropTargets(this));
     SetTreeCtrlHandler( m_pPrjMan->GetTree(), wxEVT_COMMAND_TREE_BEGIN_DRAG );
     SetTreeCtrlHandler( m_pEdMan->GetTree(),  wxEVT_COMMAND_TREE_BEGIN_DRAG );
-
-    m_nOnActivateBusy = 0;
+
+    m_nOnActivateBusy = 0;
     m_ExternalPid = 0;
-    m_pMappedFile = 0;
+    m_pMappedFile = 0;
 
-    // ---------------------------------------
-    // load tree icons/images
-    // ---------------------------------------
-    GetConfig()->pSnipImages = new SnipImages();
+    // ---------------------------------------
+    // load tree icons/images
+    // ---------------------------------------
+    GetConfig()->pSnipImages = new SnipImages();
 
     // wait on user to open an external window with the view/snippets menu
-    if ( GetConfig()->IsExternalWindow() ) {return;}
-    // ---------------------------------------
-    // setup snippet tree docking window
-    // ---------------------------------------
-    CreateSnippetWindow();
-
+    if ( GetConfig()->IsExternalWindow() ) {return;}
+    // ---------------------------------------
+    // setup snippet tree docking window
+    // ---------------------------------------
+    CreateSnippetWindow();
+
     LOGIT(wxT("idViewSnippets[%d]"), idViewSnippets);
 
-}//OnAttach
-
+}//OnAttach
+
 // ----------------------------------------------------------------------------
-void CodeSnippets::OnRelease(bool appShutDown)
+void CodeSnippets::OnRelease(bool appShutDown)
 // ----------------------------------------------------------------------------
 {
     // ------------------------------------------------------------
@@ -222,8 +223,8 @@
     // If floating window, we have to close it or CB crashes
     if ( GetConfig()->IsFloatingWindow() )
     {
-        CodeBlocksDockEvent evt(cbEVT_REMOVE_DOCK_WINDOW);
-        evt.pWindow = GetSnippetsWindow();
+        CodeBlocksDockEvent evt(cbEVT_REMOVE_DOCK_WINDOW);
+        evt.pWindow = GetSnippetsWindow();
         Manager::Get()->ProcessEvent(evt);
 
         GetSnippetsWindow()->Destroy();
@@ -231,39 +232,39 @@
     }
 
 
-}
-
+}
+
 // ----------------------------------------------------------------------------
-void CodeSnippets::BuildMenu(wxMenuBar* menuBar)
+void CodeSnippets::BuildMenu(wxMenuBar* menuBar)
 // ----------------------------------------------------------------------------
-{
-    GetConfig()->m_pMenuBar = menuBar;
+{
+    GetConfig()->m_pMenuBar = menuBar;
     bool isSet = false;
-
-	int idx = menuBar->FindMenu(_("View"));
-	if (idx != wxNOT_FOUND) do
-	{
-		wxMenu* viewMenu = menuBar->GetMenu(idx);
-		wxMenuItemList& items = viewMenu->GetMenuItems();
-
-		// Find the first separator and insert before it
-		for (size_t i = 0; i < items.GetCount(); ++i)
-		{
-			if (items[i]->IsSeparator())
-			{
+
+	int idx = menuBar->FindMenu(_("View"));
+	if (idx != wxNOT_FOUND) do
+	{
+		wxMenu* viewMenu = menuBar->GetMenu(idx);
+		wxMenuItemList& items = viewMenu->GetMenuItems();
+
+		// Find the first separator and insert before it
+		for (size_t i = 0; i < items.GetCount(); ++i)
+		{
+			if (items[i]->IsSeparator())
+			{
 				viewMenu->InsertCheckItem(i, idViewSnippets, _("Code snippets"), _("Toggle displaying the code snippets."));
-				isSet = true;
-				break;
-			}
-		}//for
-
+				isSet = true;
+				break;
+			}
+		}//for
+
 		// Not found, just append
-		if (not isSet)
-            viewMenu->AppendCheckItem(idViewSnippets, _("Code snippets"), _("Toggle displaying the code snippets."));
-	}while(0);
-	LOGIT(wxT("Menubar[%p]idViewSnippets[%d]"),menuBar, idViewSnippets);
-}
-
+		if (not isSet)
+            viewMenu->AppendCheckItem(idViewSnippets, _("Code snippets"), _("Toggle displaying the code snippets."));
+	}while(0);
+	LOGIT(wxT("Menubar[%p]idViewSnippets[%d]"),menuBar, idViewSnippets);
+}
+
 // ----------------------------------------------------------------------------
 void CodeSnippets::CreateSnippetWindow()
 // ----------------------------------------------------------------------------
@@ -272,7 +273,7 @@
 
     // GetConfig()->m_ExternalPid will contain the resulting launched pgm Pid if successful
    	if ( GetConfig()->GetSettingsWindowState().Contains(wxT("External")) )
-    {
+    {
         /*bool result =*/ LaunchExternalSnippets();
         return;
     }
@@ -297,11 +298,11 @@
 	evt.floatingSize.Set(300, 400);
 	evt.minimumSize.Set( 30, 40 );
 	// assume floating window
-    evt.dockSide = CodeBlocksDockEvent::dsFloating;
+    evt.dockSide = CodeBlocksDockEvent::dsFloating;
 ////    #if defined(__WXMSW__)
-////        evt.stretch = false; //must be false for Floating window (MSW)
-////    #else
-        evt.stretch = true; //must be true for Floating window (GTK)
+////        evt.stretch = false; //must be false for Floating window (MSW)
+////    #else
+        evt.stretch = true; //must be true for Floating window (GTK)
 ////    #endif
 
 	if ( GetConfig()->GetSettingsWindowState().Contains(wxT("Docked")) )
@@ -310,11 +311,11 @@
         evt.stretch = true;
 	}
 
-     //LOGIT( _T("CreateSnippetWindow[%s]"), GetConfig()->GetSettingsWindowState().c_str() );
+     //LOGIT( _T("CreateSnippetWindow[%s]"), GetConfig()->GetSettingsWindowState().c_str() );
 	Manager::Get()->ProcessEvent(evt);
 
 
-    #if defined(__WXMSW__)
+    #if defined(__WXMSW__)
     // Linux never creates an initial floating window. So skip this.
         // Set floating window to last position and size (except linux with buggy wxAUI)
         //if ( evt.dockSide==CodeBlocksDockEvent::dsFloating)
@@ -323,13 +324,13 @@
             GetSnippetsWindow()->GetParent()->SetSize(GetConfig()->windowXpos, GetConfig()->windowYpos,
                 GetConfig()->windowWidth, GetConfig()->windowHeight);
             // connect to the wxAUI EVT_CLOSE event
-            if ( not GetConfig()->m_pEvtCloseConnect )
+            if ( not GetConfig()->m_pEvtCloseConnect )
             {   GetSnippetsWindow()->GetParent()->Connect( wxEVT_CLOSE_WINDOW,
                         (wxObjectEventFunction)(wxEventFunction)
                         (wxCloseEventFunction) &CodeSnippetsWindow::OnClose,NULL,this);
                 GetConfig()->m_pEvtCloseConnect = GetSnippetsWindow()->GetParent();
             }
-        }
+        }
     #endif
 
     //    LOGIT( _T("[%s]X[%d]Y[%d]Width[%d]Height[%d]"),
@@ -386,7 +387,7 @@
 }
 
 // ----------------------------------------------------------------------------
-void CodeSnippets::OnViewSnippets(wxCommandEvent& event)
+void CodeSnippets::OnViewSnippets(wxCommandEvent& event)
 // ----------------------------------------------------------------------------
 {
         // ---------------------------------------
@@ -430,7 +431,7 @@
             event.IsChecked(),
             IsWindowReallyShown(GetSnippetsWindow())
             );
-
+
     // hiding window remember last window position
     if ( IsWindowReallyShown(GetSnippetsWindow()) ) do
     {   if (not event.IsChecked()) //hiding window
@@ -440,36 +441,36 @@
             {
                 GetConfig()->SettingsSaveWinPosition();
                 if ( GetConfig()->m_pEvtCloseConnect )
-                    GetSnippetsWindow()->GetParent()->Disconnect( wxEVT_CLOSE_WINDOW,
-                        (wxObjectEventFunction)(wxEventFunction)
+                    GetSnippetsWindow()->GetParent()->Disconnect( wxEVT_CLOSE_WINDOW,
+                        (wxObjectEventFunction)(wxEventFunction)
                         (wxCloseEventFunction) &CodeSnippetsWindow::OnClose,NULL,this);
                 GetConfig()->m_pEvtCloseConnect = 0;
             }
 
             LOGIT( _T("OnViewSnippets Saving Settings on HideWindow"));
             GetConfig()->SettingsSave();
-        }
+        }
     }while(0);
 
-	CodeBlocksDockEvent evt(event.IsChecked() ? cbEVT_SHOW_DOCK_WINDOW : cbEVT_HIDE_DOCK_WINDOW);
-	evt.pWindow = GetSnippetsWindow();
-	Manager::Get()->ProcessEvent(evt);
-
-    // connect to the wxAUI EVT_CLOSE event
-    if ( event.IsChecked() && GetConfig()->IsFloatingWindow()  )
+	CodeBlocksDockEvent evt(event.IsChecked() ? cbEVT_SHOW_DOCK_WINDOW : cbEVT_HIDE_DOCK_WINDOW);
+	evt.pWindow = GetSnippetsWindow();
+	Manager::Get()->ProcessEvent(evt);
+
+    // connect to the wxAUI EVT_CLOSE event
+    if ( event.IsChecked() && GetConfig()->IsFloatingWindow()  )
     {   if( not GetConfig()->m_pEvtCloseConnect )
-        {   GetSnippetsWindow()->GetParent()->Connect( wxEVT_CLOSE_WINDOW,
-                (wxObjectEventFunction)(wxEventFunction)
+        {   GetSnippetsWindow()->GetParent()->Connect( wxEVT_CLOSE_WINDOW,
+                (wxObjectEventFunction)(wxEventFunction)
                 (wxCloseEventFunction) &CodeSnippetsWindow::OnClose,NULL,this);
             GetConfig()->m_pEvtCloseConnect = GetSnippetsWindow()->GetParent();
         }
-    }//if
-}
-
+    }//if
+}
+
 // ----------------------------------------------------------------------------
-void CodeSnippets::OnUpdateUI(wxUpdateUIEvent& /*event*/)
+void CodeSnippets::OnUpdateUI(wxUpdateUIEvent& /*event*/)
 // ----------------------------------------------------------------------------
-{
+{
 
     wxMenuBar* pbar = Manager::Get()->GetAppWindow()->GetMenuBar();
 
@@ -494,7 +495,7 @@
     // Floating or Docked snippets window
     // -----------------------------------
 	// Check if the Code Snippets window is visible, if it's not, uncheck the menu item
-	if (GetSnippetsWindow() )
+	if (GetSnippetsWindow() )
     {    pbar->Check(idViewSnippets, IsWindowReallyShown(GetSnippetsWindow()));
         return;
     }
@@ -505,20 +506,20 @@
         pbar->Check(idViewSnippets, m_ExternalPid!=0);
 
     }
-
-}
+
+}
 // ----------------------------------------------------------------------------
 void CodeSnippets::OnIdle(wxIdleEvent& event)
 // ----------------------------------------------------------------------------
 {
     // Because the current wxAUI is such a lousy interface, we have to poll
     // our docked window to see if it has closed. There are no events
-    // that tell us if the user closed the docked or floating window.
+    // that tell us if the user closed the docked or floating window.
 
     // Unfortunately wxAUI crashes when we close a docked window
     // When user closes docked window with system [x] button, wxAUI crashes
-    ////    if ( GetConfig()->IsDockedWindow() )
-    ////         { event.Skip(); return; }
+    ////    if ( GetConfig()->IsDockedWindow() )
+    ////         { event.Skip(); return; }
 
     // Don't close down if file checking is active
     if (m_nOnActivateBusy) { event.Skip();return; }
@@ -1270,10 +1271,10 @@
             wxString ldLibraryPath = ::wxPathOnly( cmd ) + wxT("/");
             if ( wxDirExists( ldLibraryPath + wxT("./lib")) ) ldLibraryPath << wxT("./lib");
             if ( wxDirExists( ldLibraryPath + wxT("../lib")) ) ldLibraryPath << wxT("../lib");
-            ldLibraryPath << wxT(":$LD_LIBRARY_PATH");
+            ldLibraryPath << wxT(":$LD_LIBRARY_PATH");
             wxSetEnv( _T("LD_LIBRARY_PATH"), ldLibraryPath );
             wxGetEnv( _T("LD_LIBRARY_PATH"), &ldLibraryPath );
-            Manager::Get()->GetMessageManager()->DebugLog(wxString::Format( _("CodeSnippets CWD: %s"), cwd.c_str()) );
+            Manager::Get()->GetMessageManager()->DebugLog(wxString::Format( _("CodeSnippets CWD: %s"), cwd.c_str()) );
             Manager::Get()->GetMessageManager()->DebugLog(wxString::Format( _("CodeSnippets LD_LIBRARY_PATH is: %s"), ldLibraryPath.c_str()) );
         #endif // __APPLE__ && __MACH__
     #endif
@@ -1281,7 +1282,7 @@
     // start codesnippets
     Manager::Get()->GetMessageManager()->DebugLog( _("Starting program:")+cmd);
     m_ExternalPid = wxExecute(cmd, wxEXEC_ASYNC);
-     LOGIT( _T("Launch [%s\n] from [%s]\n] Pid[%lu]"), cmd.c_str(), cwd.c_str(), m_ExternalPid );
+     LOGIT( _T("Launch [%s\n] from [%s]\n] Pid[%lu]"), cmd.c_str(), cwd.c_str(), m_ExternalPid );
 
     #if defined(__WXMAC__)
         if (m_ExternalPid == -1)
@@ -1373,29 +1374,29 @@
     std::strncpy(pMappedData, cbU2C(myPid), myPid.Length());
     //pMappedFile->UnmapFile(); will deallocate the file (so will the dtor)
 
-
-    // Launch the external process
-    wxString execFolder = GetConfig()->m_ExecuteFolder;
-    wxString PgmFullPath ;
+
+    // Launch the external process
+    wxString execFolder = GetConfig()->m_ExecuteFolder;
+    wxString PgmFullPath ;
     do {
-        PgmFullPath = execFolder + wxT("/codesnippets");
-        #if defined(__WXMSW__)
-            PgmFullPath << wxT(".exe");
-        #endif
-        if ( ::wxFileExists(PgmFullPath) ) break;
-        LOGIT(wxT("codesnippets not found at[%s]"),PgmFullPath.GetData());
-
-        PgmFullPath = execFolder
-                    + wxT("/share/codeblocks/plugins/codesnippets");
-        #if defined(__WXMSW__)
-            PgmFullPath << wxT(".exe") ;
+        PgmFullPath = execFolder + wxT("/codesnippets");
+        #if defined(__WXMSW__)
+            PgmFullPath << wxT(".exe");
         #endif
-    }while(0);
-
+        if ( ::wxFileExists(PgmFullPath) ) break;
+        LOGIT(wxT("codesnippets not found at[%s]"),PgmFullPath.GetData());
+
+        PgmFullPath = execFolder
+                    + wxT("/share/codeblocks/plugins/codesnippets");
+        #if defined(__WXMSW__)
+            PgmFullPath << wxT(".exe") ;
+        #endif
+    }while(0);
+
     wxString pgmArgs( wxString::Format( wxT("KeepAlivePid=%lu"), ::wxGetProcessId() ) );
     wxString command = PgmFullPath + wxT(" ") + pgmArgs;
 
-     LOGIT( _T("Launching[%s]"), command.GetData());
+     LOGIT( _T("Launching[%s]"), command.GetData());
 
     bool result = LaunchProcess(command, wxGetCwd());
      LOGIT( _T("Launch Result[%d] m_ExternalPid[%lu]"),result, m_ExternalPid );
Index: src/plugins/contrib/wxSmith/wxsresource.cpp
===================================================================
--- src/plugins/contrib/wxSmith/wxsresource.cpp	(revision 4255)
+++ src/plugins/contrib/wxSmith/wxsresource.cpp	(working copy)
@@ -26,6 +26,7 @@
 #include "wxsresourcetreeitemdata.h"
 
 #include <wx/wxFlatNotebook/wxFlatNotebook.h>
+#include <tearawaynotebook.h>
 #include <editormanager.h>
 
 namespace
Index: src/plugins/contrib/wxSmith/wxsmith.cpp
===================================================================
--- src/plugins/contrib/wxSmith/wxsmith.cpp	(revision 4255)
+++ src/plugins/contrib/wxSmith/wxsmith.cpp	(working copy)
@@ -30,6 +30,7 @@
 #include "properties/wxsproperties.h"
 
 #include <wx/wxFlatNotebook/wxFlatNotebook.h>
+#include <tearawaynotebook.h>
 #include <projectloader_hooks.h>
 #include <projectmanager.h>
 #include <messagemanager.h>
Index: src/plugins/codecompletion/nativeparser.cpp
===================================================================
--- src/plugins/codecompletion/nativeparser.cpp	(revision 4255)
+++ src/plugins/codecompletion/nativeparser.cpp	(working copy)
@@ -43,7 +43,8 @@
 #include <wx/regex.h>
 #include <wx/log.h> // for wxSafeShowMessage()
 #include <tinyxml/tinyxml.h>
-#include "wx/wxFlatNotebook/wxFlatNotebook.h"
+#include <wx/wxFlatNotebook/wxFlatNotebook.h>
+#include <tearawaynotebook.h>
 
 #include <wx/wfstream.h>
 
Index: src/include/projectmanager.h
===================================================================
--- src/include/projectmanager.h	(revision 4255)
+++ src/include/projectmanager.h	(working copy)
@@ -22,6 +22,7 @@
 class ProjectFile;
 class FilesGroupsAndMasks;
 class cbWorkspace;
+class TearawayNotebook;
 class wxFlatNotebook;
 class wxFlatNotebookEvent;
 
@@ -50,7 +51,7 @@
         ProjectManager(const ProjectManager& rhs) { cbThrow(_T("Can't call ProjectManager's copy ctor!!!")); }
         virtual void operator=(const ProjectManager& rhs){ cbThrow(_T("Can't assign an ProjectManager* !!!")); }
 
-        wxFlatNotebook* GetNotebook() { return m_pNotebook; }
+        TearawayNotebook* GetNotebook() { return m_pNotebook; }
 
         // Can the app shutdown? (actually: is ProjectManager busy at the moment?)
         static bool CanShutdown(){ return s_CanShutdown; }
@@ -462,15 +463,17 @@
         void OnDeleteVirtualFolder(wxCommandEvent& event);
         void OnUpdateUI(wxUpdateUIEvent& event);
         void OnIdle(wxIdleEvent& event);
+        void OnDetach(wxCommandEvent& event);
         void OnAppDoneStartup(CodeBlocksEvent& event);
-
+        void OnPageContextMenu(wxFlatNotebookEvent& event);
         void DoOpenSelectedFile();
         void DoOpenFile(ProjectFile* pf, const wxString& filename);
         int DoAddFileToProject(const wxString& filename, cbProject* project, wxArrayInt& targets);
         void RemoveFilesRecursively(wxTreeItemId& sel_id);
 
-        wxFlatNotebook* m_pNotebook;
+        TearawayNotebook* m_pNotebook;
         wxTreeCtrl* m_pTree;
+        wxPanel *m_panel;
         wxTreeItemId m_TreeRoot;
         cbProject* m_pActiveProject;
         wxImageList* m_pImages;
Index: src/include/messagemanager.h
===================================================================
--- src/include/messagemanager.h	(revision 4255)
+++ src/include/messagemanager.h	(working copy)
@@ -37,6 +37,7 @@
 // forward decls
 class wxMenuBar;
 class wxBitmap;
+class TearawayNotebook;
 class wxFlatNotebook;
 class wxFlatNotebookEvent;
 
@@ -82,7 +83,7 @@
 		void ReleaseMenu(wxMenuBar* menuBar);
 
         /** @return the wxFlatNotebook control that MessageManager controls. */
-		wxFlatNotebook* GetNotebook() { return m_pNotebook; }
+		TearawayNotebook* GetNotebook() { return m_pNotebook; }
 
         /** @brief Add a new log window.
           * @param log The log window to add.
@@ -263,8 +264,9 @@
         void OnShowHideLog(wxCommandEvent& event);
         void OnPageChanged(wxFlatNotebookEvent& event);
         void OnPageContextMenu(wxFlatNotebookEvent& event);
+        void OnDetach(wxCommandEvent& event);
 
-        wxFlatNotebook* m_pNotebook;
+        TearawayNotebook* m_pNotebook;
         LogsMap m_Logs;
 		int m_AppLog;
 		int m_DebugLog;
Index: src/include/tearawaynotebook.h
===================================================================
--- src/include/tearawaynotebook.h	(revision 0)
+++ src/include/tearawaynotebook.h	(revision 0)
@@ -0,0 +1,54 @@
+///////////////////////////////////////////////////////////////////////////////
+// Name:		tearwaynotebook.h
+// Purpose:     flatnotebook derived class supporting detachable and dockable pages.
+// Author:      Damien Moore
+// Created:     30/6/2007
+// Copyright:   Damien Moore (c)
+// Licence:     GPL v2
+///////////////////////////////////////////////////////////////////////////////
+
+#ifndef TEARAWAYNOTEBOOK_H
+#define TEARAWAYNOTEBOOK_H
+
+#include "wx/wxFlatNotebook/wxFlatNotebook.h"
+#include <wx/dynarray.h>
+
+#include "sdk_events.h"
+
+WX_DECLARE_OBJARRAY(wxWindow*, wxWindowArray);
+
+
+class TearawayNotebook : public wxFlatNotebook
+{
+public:
+    // Constructors/Destructors
+    TearawayNotebook() : wxFlatNotebook() {}
+    TearawayNotebook(wxWindow* parent, wxWindowID id = wxID_ANY, const wxPoint& pos = wxDefaultPosition,
+        const wxSize& size = wxDefaultSize, long style = 0, const wxString& name = wxT("Tearaway Notebook"))
+        : wxFlatNotebook(parent, id, pos, size, style, name) {}
+    virtual ~TearawayNotebook();
+    bool IsDetached(size_t page);
+    // Detaches page and puts it in a dockable
+    bool DetachPage(size_t page, wxString windowname);
+    // If user hide the dockable
+    bool UndetachPage(size_t page);
+    void SetSelection(size_t page);
+	bool AddPage(wxWindow* page, const wxString& caption, const bool selected = false, const int imgindex = -1);
+	bool InsertPage(size_t index, wxWindow* page, const wxString& text, bool select = false, const int imgindex = -1);
+    void DeletePage(size_t page, bool notify = true);
+    bool RemovePage(size_t page, bool notify = true);
+    bool DeleteAllPages();
+    wxString GetDetached();
+    void SetDetached(wxString s);
+    void UndetachAllPages();
+	//void OnHideDetachedPage(CodeBlocksDockEvent &event);
+private:
+	wxWindowArray m_detachedwindow;
+    void OnDockWindowVisibility(CodeBlocksDockEvent& event);
+	DECLARE_DYNAMIC_CLASS(TearawayNotebook)
+	DECLARE_EVENT_TABLE()
+};
+
+
+#endif // TEARAWAYNOTEBOOK_H
+
Index: src/include/wxFlatNotebook/include/wx/wxFlatNotebook/wxFlatNotebook.h
===================================================================
--- src/include/wxFlatNotebook/include/wx/wxFlatNotebook/wxFlatNotebook.h	(revision 4255)
+++ src/include/wxFlatNotebook/include/wx/wxFlatNotebook/wxFlatNotebook.h	(working copy)
@@ -1,5 +1,5 @@
 ///////////////////////////////////////////////////////////////////////////////
-// Name:		wxFlatNotebook.cpp 
+// Name:		wxFlatNotebook.cpp
 // Purpose:     generic implementation of flat style notebook class.
 // Author:      Eran Ifrah <eranif@bezeqint.net>
 // Modified by: Priyank Bolia <soft@priyank.in>
@@ -128,7 +128,7 @@
 	\param selected - determines if new page should be selected automatically
 	\param imgindex - page image index
 	*/
-	bool AddPage(wxWindow* windows, const wxString& caption, const bool selected = false, const int imgindex = -1);
+	virtual bool AddPage(wxWindow* windows, const wxString& caption, const bool selected = false, const int imgindex = -1);
 
 	/// Inserts new notebook page
 	/**
@@ -138,24 +138,24 @@
 	\param select - determines if new page should be selected automatically
 	\param imgindex - page image index
 	*/
-	bool InsertPage(size_t index, wxWindow* page, const wxString& text, bool select = false, const int imgindex = -1);
+	virtual bool InsertPage(size_t index, wxWindow* page, const wxString& text, bool select = false, const int imgindex = -1);
 	/// Changes the selection from currently visible/selected page to the page given by index.
 	/**
 	\param page - index of page to be selected
 	*/
-	void SetSelection(size_t page);
+	virtual void SetSelection(size_t page);
 	/// Removes the window from the notebook, and destroys the window associated with that notebook page.
 	/**
 	 * \param page - index of page to be deleted
 	 * \param notify - by default wxFlatNotebook fires two events:
-	 * - wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSED 
-	 * - wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSING 
+	 * - wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSED
+	 * - wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSING
 	 * to disable this functionality set notify to false
 	 */
-	void DeletePage(size_t page, bool notify = true);
+	virtual void DeletePage(size_t page, bool notify = true);
 
 	/// Deletes all notebook pages and destroys all windows associated with pages
-	bool DeleteAllPages();
+	virtual bool DeleteAllPages();
 
 	/// Returns the total number of pages in the notebook.
 	int  GetPageCount() const;
@@ -179,7 +179,7 @@
 
 	/**
 	* Return the previous selection, useful when implementing smart tabulation
-	* \return previous selection, or wxNOT_FOUND 
+	* \return previous selection, or wxNOT_FOUND
 	*/
 	int GetPreviousSelection() const;
 
@@ -215,11 +215,11 @@
 	 * Removes the window from the notebook, and destroys the window associated with that notebook page.
 	 * \param page - index of page to be deleted
 	 * \param notify - by default wxFlatNotebook fires two events:
-	 * - wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSED 
-	 * - wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSING 
+	 * - wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSED
+	 * - wxEVT_COMMAND_FLATNOTEBOOK_PAGE_CLOSING
 	 * to disable this functionality set notify to false
 	 */
-	bool RemovePage(size_t page, bool notify = true);
+	virtual bool RemovePage(size_t page, bool notify = true);
 
 	/// Sets the amount of space around each page's icon and label, in pixels.
 	/**
@@ -359,8 +359,7 @@
 	/// Initialization function, called internally
 	virtual void Init();
 	wxPageContainer *m_pages;
-
-private:
+//private: //use protected instead
 	/// Internal flag to force selection of page,
 	/// even if this page is disabled.
 	/// used incase such that the book itself need to update its selection.
@@ -543,7 +542,7 @@
 class WXDLLIMPEXP_FNB wxPageContainer : public wxPanel
 {
 protected:
-
+    friend class TearawayNotebook;
 	friend class wxFlatNotebook;
 	friend class wxFNBRenderer;
 	friend class wxFNBRendererDefault;
@@ -694,7 +693,7 @@
 	int GetPreviousSelection() const { return m_iPreviousActivePage; }
 
 	/**
-	 * Draw a tab preview 
+	 * Draw a tab preview
 	 */
 	void DrawDragHint();
 
Index: src/include/editormanager.h
===================================================================
--- src/include/editormanager.h	(revision 4255)
+++ src/include/editormanager.h	(working copy)
@@ -23,8 +23,10 @@
 
 // forward decls
 class EditorBase;
+class TearawayNotebook;
 class wxFlatNotebook;
 class wxFlatNotebookEvent;
+class wxFlatNotebookImageList;
 class wxMenuBar;
 class EditorColourSet;
 class cbProject;
@@ -53,7 +55,7 @@
         EditorManager(const EditorManager& rhs) { cbThrow(_T("Can't call EditorManager's copy ctor!!!")); }
         virtual void operator=(const EditorManager& rhs){ cbThrow(_T("Can't assign an EditorManager* !!!")); }
 
-        wxFlatNotebook* GetNotebook(){ return m_pNotebook; }
+        TearawayNotebook* GetNotebook(){ return m_pNotebook; }
         void CreateMenu(wxMenuBar* menuBar);
         void ReleaseMenu(wxMenuBar* menuBar);
         void Configure();
@@ -141,6 +143,7 @@
         void OnPageChanging(wxFlatNotebookEvent& event);
         void OnPageClosing(wxFlatNotebookEvent& event);
         void OnPageContextMenu(wxFlatNotebookEvent& event);
+        void OnDetach(wxCommandEvent& event);
         void OnClose(wxCommandEvent& event);
         void OnCloseAll(wxCommandEvent& event);
         void OnCloseAllOthers(wxCommandEvent& event);
@@ -189,7 +192,7 @@
         int ReplaceInFiles(cbFindReplaceData* data);
         int GetOpenFilesListIcon(EditorBase* ed);
 
-        wxFlatNotebook* m_pNotebook;
+        TearawayNotebook* m_pNotebook;
         cbFindReplaceData* m_LastFindReplaceData;
         EditorColourSet* m_Theme;
         wxTreeCtrl* m_pTree;
@@ -202,6 +205,7 @@
         bool m_isCheckingForExternallyModifiedFiles;
         friend struct EditorManagerInternalData;
         EditorManagerInternalData* m_pData;
+        wxFlatNotebookImageList *m_NotebookImages;
 
         DECLARE_EVENT_TABLE()
 };
Index: src/src/main.cpp
===================================================================
--- src/src/main.cpp	(revision 4255)
+++ src/src/main.cpp	(working copy)
@@ -69,6 +69,7 @@
 #include <wx/printdlg.h>
 #include <wx/filename.h>
 #include <wx/wxFlatNotebook/wxFlatNotebook.h>
+#include "tearawaynotebook.h"
 
 #include "uservarmanager.h"
 #include "infowindow.h"
@@ -526,7 +527,7 @@
     DoFixToolbarsLayout();
     gDefaultLayoutData = m_LayoutManager.SavePerspective(); // keep the "hardcoded" layout handy
     SaveViewLayout(gDefaultLayout, gDefaultLayoutData);
-    LoadWindowState();
+//    LoadWindowState();
 
     ShowHideStartPage();
     m_ScriptConsoleVisible = Manager::Get()->GetConfigManager(_T("app"))->ReadBool(_T("/show_script_console"), false);
@@ -539,7 +540,7 @@
 	RunStartupScripts();
 
     m_StartupDone = true;
-    DoUpdateLayout();
+//    DoUpdateLayout();
 
     if (Manager::Get()->GetMessageManager()->HasErrors())
     {
@@ -558,6 +559,8 @@
 
 	CodeBlocksEvent event(cbEVT_APP_STARTUP_DONE);
 	Manager::Get()->ProcessEvent(event);
+    LoadWindowState();
+    DoUpdateLayout();
 }
 
 MainFrame::~MainFrame()
@@ -574,7 +577,7 @@
 	Manager* pm = Manager::Get();
 
     pm->RegisterEventSink(cbEVT_EDITOR_UPDATE_UI, new cbEventFunctor<MainFrame, CodeBlocksEvent>(this, &MainFrame::OnEditorUpdateUI));
-    
+
     pm->RegisterEventSink(cbEVT_PROJECT_ACTIVATE, new cbEventFunctor<MainFrame, CodeBlocksEvent>(this, &MainFrame::OnProjectActivated));
     pm->RegisterEventSink(cbEVT_PROJECT_OPEN, new cbEventFunctor<MainFrame, CodeBlocksEvent>(this, &MainFrame::OnProjectOpened));
     pm->RegisterEventSink(cbEVT_PROJECT_CLOSE, new cbEventFunctor<MainFrame, CodeBlocksEvent>(this, &MainFrame::OnProjectClosed));
@@ -583,18 +586,18 @@
     pm->RegisterEventSink(cbEVT_EDITOR_ACTIVATED, new cbEventFunctor<MainFrame, CodeBlocksEvent>(this, &MainFrame::OnEditorActivated));
     pm->RegisterEventSink(cbEVT_EDITOR_SAVE, new cbEventFunctor<MainFrame, CodeBlocksEvent>(this, &MainFrame::OnEditorSaved));
     pm->RegisterEventSink(cbEVT_EDITOR_MODIFIED, new cbEventFunctor<MainFrame, CodeBlocksEvent>(this, &MainFrame::OnEditorModified));
-    
+
     pm->RegisterEventSink(cbEVT_ADD_DOCK_WINDOW, new cbEventFunctor<MainFrame, CodeBlocksDockEvent>(this, &MainFrame::OnRequestDockWindow));
     pm->RegisterEventSink(cbEVT_REMOVE_DOCK_WINDOW, new cbEventFunctor<MainFrame, CodeBlocksDockEvent>(this, &MainFrame::OnRequestUndockWindow));
     pm->RegisterEventSink(cbEVT_SHOW_DOCK_WINDOW, new cbEventFunctor<MainFrame, CodeBlocksDockEvent>(this, &MainFrame::OnRequestShowDockWindow));
     pm->RegisterEventSink(cbEVT_HIDE_DOCK_WINDOW, new cbEventFunctor<MainFrame, CodeBlocksDockEvent>(this, &MainFrame::OnRequestHideDockWindow));
     pm->RegisterEventSink(cbEVT_DOCK_WINDOW_VISIBILITY, new cbEventFunctor<MainFrame, CodeBlocksDockEvent>(this, &MainFrame::OnDockWindowVisibility));
-    
+
     pm->RegisterEventSink(cbEVT_PLUGIN_ATTACHED, new cbEventFunctor<MainFrame, CodeBlocksEvent>(this, &MainFrame::OnPluginLoaded));
     pm->RegisterEventSink(cbEVT_PLUGIN_RELEASED, new cbEventFunctor<MainFrame, CodeBlocksEvent>(this, &MainFrame::OnPluginUnloaded));
     pm->RegisterEventSink(cbEVT_PLUGIN_INSTALLED, new cbEventFunctor<MainFrame, CodeBlocksEvent>(this, &MainFrame::OnPluginInstalled));
     pm->RegisterEventSink(cbEVT_PLUGIN_UNINSTALLED, new cbEventFunctor<MainFrame, CodeBlocksEvent>(this, &MainFrame::OnPluginUninstalled));
-    
+
     pm->RegisterEventSink(cbEVT_SWITCH_VIEW_LAYOUT, new cbEventFunctor<MainFrame, CodeBlocksLayoutEvent>(this, &MainFrame::OnLayoutSwitch));
 }
 
@@ -1049,6 +1052,14 @@
 
 void MainFrame::LoadWindowState()
 {
+    // load detached state of manager and messages pages and add the detached windows
+    Manager::Get()->GetProjectManager()->GetNotebook()->SetDetached(Manager::Get()->GetConfigManager(_T("app"))->Read(_T("/main_frame/layout/left_block_detached"), _T("")));
+    Manager::Get()->GetMessageManager()->GetNotebook()->SetDetached(Manager::Get()->GetConfigManager(_T("app"))->Read(_T("/main_frame/layout/bottom_block_detached"), _T("")));
+    // load manager and messages selected page
+    Manager::Get()->GetProjectManager()->GetNotebook()->SetSelection(Manager::Get()->GetConfigManager(_T("app"))->ReadInt(_T("/main_frame/layout/left_block_selection"), 0));
+    Manager::Get()->GetMessageManager()->GetNotebook()->SetSelection(Manager::Get()->GetConfigManager(_T("app"))->ReadInt(_T("/main_frame/layout/bottom_block_selection"), 0));
+
+
     wxArrayString subs = Manager::Get()->GetConfigManager(_T("app"))->EnumerateSubPaths(_T("/main_frame/layout"));
     for (size_t i = 0; i < subs.GetCount(); ++i)
     {
@@ -1059,9 +1070,9 @@
     wxString deflayout = Manager::Get()->GetConfigManager(_T("app"))->Read(_T("/main_frame/layout/default"));
     LoadViewLayout(deflayout);
 
-    // load manager and messages selected page
-    Manager::Get()->GetProjectManager()->GetNotebook()->SetSelection(Manager::Get()->GetConfigManager(_T("app"))->ReadInt(_T("/main_frame/layout/left_block_selection"), 0));
-    Manager::Get()->GetMessageManager()->GetNotebook()->SetSelection(Manager::Get()->GetConfigManager(_T("app"))->ReadInt(_T("/main_frame/layout/bottom_block_selection"), 0));
+//    // load manager and messages selected page
+//    Manager::Get()->GetProjectManager()->GetNotebook()->SetSelection(Manager::Get()->GetConfigManager(_T("app"))->ReadInt(_T("/main_frame/layout/left_block_selection"), 0));
+//    Manager::Get()->GetMessageManager()->GetNotebook()->SetSelection(Manager::Get()->GetConfigManager(_T("app"))->ReadInt(_T("/main_frame/layout/bottom_block_selection"), 0));
 
 #ifndef __WXMAC__
     int x = 0;
@@ -1102,6 +1113,10 @@
         Manager::Get()->GetConfigManager(_T("app"))->Write(key + _T("data"), it->second);
     }
 
+    // save detached state of manager and messages pages
+    Manager::Get()->GetConfigManager(_T("app"))->Write(_T("/main_frame/layout/left_block_detached"), Manager::Get()->GetProjectManager()->GetNotebook()->GetDetached());
+    Manager::Get()->GetConfigManager(_T("app"))->Write(_T("/main_frame/layout/bottom_block_detached"), Manager::Get()->GetMessageManager()->GetNotebook()->GetDetached());
+
     // save manager and messages selected page
     Manager::Get()->GetConfigManager(_T("app"))->Write(_T("/main_frame/layout/left_block_selection"), Manager::Get()->GetProjectManager()->GetNotebook()->GetSelection());
     Manager::Get()->GetConfigManager(_T("app"))->Write(_T("/main_frame/layout/bottom_block_selection"), Manager::Get()->GetMessageManager()->GetNotebook()->GetSelection());
Index: src/src/app.cpp
===================================================================
--- src/src/app.cpp	(revision 4255)
+++ src/src/app.cpp	(working copy)
@@ -51,6 +51,7 @@
 #include <manager.h>
 #include <scriptingmanager.h>
 #include <wx/wxFlatNotebook/wxFlatNotebook.h>
+#include "tearawaynotebook.h"
 #include <globals.h>
 #include "splashscreen.h"
 #include <wx/arrstr.h>
Index: src/CodeBlocks-unix.cbp
===================================================================
--- src/CodeBlocks-unix.cbp	(revision 4255)
+++ src/CodeBlocks-unix.cbp	(working copy)
@@ -110,6 +110,7 @@
 				<Option projectResourceIncludeDirsRelation="2" />
 				<Compiler>
 					<Add directory="include/wxFlatNotebook/include" />
+					<Add directory="$(#cb)/include" />
 				</Compiler>
 			</Target>
 			<Target title="wxPropertyGrid">
@@ -175,7 +176,7 @@
 				<Option external_deps="src/wxAUI/libwxaui.a;" />
 				<Option type="0" />
 				<Option compiler="gcc" />
-				<Option parameters="--debug-log -ns" />
+				<Option parameters="--debug-log -ns --personality=debug" />
 				<Option projectLinkerOptionsRelation="2" />
 				<Option projectIncludeDirsRelation="2" />
 				<Option projectResourceIncludeDirsRelation="0" />
@@ -854,6 +855,9 @@
 		<Unit filename="include/simpletextlog.h">
 			<Option target="sdk" />
 		</Unit>
+		<Unit filename="include/tearawaynotebook.h">
+			<Option target="sdk" />
+		</Unit>
 		<Unit filename="include/templatemanager.h">
 			<Option target="sdk" />
 		</Unit>
@@ -2498,6 +2502,9 @@
 		<Unit filename="sdk/simpletextlog.cpp">
 			<Option target="sdk" />
 		</Unit>
+		<Unit filename="sdk/tearawaynotebook.cpp">
+			<Option target="sdk" />
+		</Unit>
 		<Unit filename="sdk/templatemanager.cpp">
 			<Option target="sdk" />
 		</Unit>
